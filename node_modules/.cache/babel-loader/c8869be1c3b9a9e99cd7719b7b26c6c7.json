{"ast":null,"code":"import Emitter from \"./emitter.js\";\nimport defaultOptions from \"./options.js\";\nexport default class Dropzone extends Emitter {\n  static initClass() {\n    // Exposing the emitter class, mainly for tests\n    this.prototype.Emitter = Emitter;\n    /*\n     This is a list of all available events you can register on a dropzone object.\n      You can register an event handler like this:\n      dropzone.on(\"dragEnter\", function() { });\n      */\n\n    this.prototype.events = [\"drop\", \"dragstart\", \"dragend\", \"dragenter\", \"dragover\", \"dragleave\", \"addedfile\", \"addedfiles\", \"removedfile\", \"thumbnail\", \"error\", \"errormultiple\", \"processing\", \"processingmultiple\", \"uploadprogress\", \"totaluploadprogress\", \"sending\", \"sendingmultiple\", \"success\", \"successmultiple\", \"canceled\", \"canceledmultiple\", \"complete\", \"completemultiple\", \"reset\", \"maxfilesexceeded\", \"maxfilesreached\", \"queuecomplete\"];\n    this.prototype._thumbnailQueue = [];\n    this.prototype._processingThumbnail = false;\n  } // global utility\n\n\n  static extend(target, ...objects) {\n    for (let object of objects) {\n      for (let key in object) {\n        let val = object[key];\n        target[key] = val;\n      }\n    }\n\n    return target;\n  }\n\n  constructor(el, options) {\n    super();\n    let fallback, left;\n    this.element = el; // For backwards compatibility since the version was in the prototype previously\n\n    this.version = Dropzone.version;\n    this.clickableElements = [];\n    this.listeners = [];\n    this.files = []; // All files\n\n    if (typeof this.element === \"string\") {\n      this.element = document.querySelector(this.element);\n    } // Not checking if instance of HTMLElement or Element since IE9 is extremely weird.\n\n\n    if (!this.element || this.element.nodeType == null) {\n      throw new Error(\"Invalid dropzone element.\");\n    }\n\n    if (this.element.dropzone) {\n      throw new Error(\"Dropzone already attached.\");\n    } // Now add this dropzone to the instances.\n\n\n    Dropzone.instances.push(this); // Put the dropzone inside the element itself.\n\n    this.element.dropzone = this;\n    let elementOptions = (left = Dropzone.optionsForElement(this.element)) != null ? left : {};\n    this.options = Dropzone.extend({}, defaultOptions, elementOptions, options != null ? options : {});\n    this.options.previewTemplate = this.options.previewTemplate.replace(/\\n*/g, \"\"); // If the browser failed, just call the fallback and leave\n\n    if (this.options.forceFallback || !Dropzone.isBrowserSupported()) {\n      return this.options.fallback.call(this);\n    } // @options.url = @element.getAttribute \"action\" unless @options.url?\n\n\n    if (this.options.url == null) {\n      this.options.url = this.element.getAttribute(\"action\");\n    }\n\n    if (!this.options.url) {\n      throw new Error(\"No URL provided.\");\n    }\n\n    if (this.options.acceptedFiles && this.options.acceptedMimeTypes) {\n      throw new Error(\"You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.\");\n    }\n\n    if (this.options.uploadMultiple && this.options.chunking) {\n      throw new Error(\"You cannot set both: uploadMultiple and chunking.\");\n    } // Backwards compatibility\n\n\n    if (this.options.acceptedMimeTypes) {\n      this.options.acceptedFiles = this.options.acceptedMimeTypes;\n      delete this.options.acceptedMimeTypes;\n    } // Backwards compatibility\n\n\n    if (this.options.renameFilename != null) {\n      this.options.renameFile = file => this.options.renameFilename.call(this, file.name, file);\n    }\n\n    if (typeof this.options.method === \"string\") {\n      this.options.method = this.options.method.toUpperCase();\n    }\n\n    if ((fallback = this.getExistingFallback()) && fallback.parentNode) {\n      // Remove the fallback\n      fallback.parentNode.removeChild(fallback);\n    } // Display previews in the previewsContainer element or the Dropzone element unless explicitly set to false\n\n\n    if (this.options.previewsContainer !== false) {\n      if (this.options.previewsContainer) {\n        this.previewsContainer = Dropzone.getElement(this.options.previewsContainer, \"previewsContainer\");\n      } else {\n        this.previewsContainer = this.element;\n      }\n    }\n\n    if (this.options.clickable) {\n      if (this.options.clickable === true) {\n        this.clickableElements = [this.element];\n      } else {\n        this.clickableElements = Dropzone.getElements(this.options.clickable, \"clickable\");\n      }\n    }\n\n    this.init();\n  } // Returns all files that have been accepted\n\n\n  getAcceptedFiles() {\n    return this.files.filter(file => file.accepted).map(file => file);\n  } // Returns all files that have been rejected\n  // Not sure when that's going to be useful, but added for completeness.\n\n\n  getRejectedFiles() {\n    return this.files.filter(file => !file.accepted).map(file => file);\n  }\n\n  getFilesWithStatus(status) {\n    return this.files.filter(file => file.status === status).map(file => file);\n  } // Returns all files that are in the queue\n\n\n  getQueuedFiles() {\n    return this.getFilesWithStatus(Dropzone.QUEUED);\n  }\n\n  getUploadingFiles() {\n    return this.getFilesWithStatus(Dropzone.UPLOADING);\n  }\n\n  getAddedFiles() {\n    return this.getFilesWithStatus(Dropzone.ADDED);\n  } // Files that are either queued or uploading\n\n\n  getActiveFiles() {\n    return this.files.filter(file => file.status === Dropzone.UPLOADING || file.status === Dropzone.QUEUED).map(file => file);\n  } // The function that gets called when Dropzone is initialized. You\n  // can (and should) setup event listeners inside this function.\n\n\n  init() {\n    // In case it isn't set already\n    if (this.element.tagName === \"form\") {\n      this.element.setAttribute(\"enctype\", \"multipart/form-data\");\n    }\n\n    if (this.element.classList.contains(\"dropzone\") && !this.element.querySelector(\".dz-message\")) {\n      this.element.appendChild(Dropzone.createElement(`<div class=\"dz-default dz-message\"><button class=\"dz-button\" type=\"button\">${this.options.dictDefaultMessage}</button></div>`));\n    }\n\n    if (this.clickableElements.length) {\n      let setupHiddenFileInput = () => {\n        if (this.hiddenFileInput) {\n          this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);\n        }\n\n        this.hiddenFileInput = document.createElement(\"input\");\n        this.hiddenFileInput.setAttribute(\"type\", \"file\");\n\n        if (this.options.maxFiles === null || this.options.maxFiles > 1) {\n          this.hiddenFileInput.setAttribute(\"multiple\", \"multiple\");\n        }\n\n        this.hiddenFileInput.className = \"dz-hidden-input\";\n\n        if (this.options.acceptedFiles !== null) {\n          this.hiddenFileInput.setAttribute(\"accept\", this.options.acceptedFiles);\n        }\n\n        if (this.options.capture !== null) {\n          this.hiddenFileInput.setAttribute(\"capture\", this.options.capture);\n        } // Making sure that no one can \"tab\" into this field.\n\n\n        this.hiddenFileInput.setAttribute(\"tabindex\", \"-1\"); // Not setting `display=\"none\"` because some browsers don't accept clicks\n        // on elements that aren't displayed.\n\n        this.hiddenFileInput.style.visibility = \"hidden\";\n        this.hiddenFileInput.style.position = \"absolute\";\n        this.hiddenFileInput.style.top = \"0\";\n        this.hiddenFileInput.style.left = \"0\";\n        this.hiddenFileInput.style.height = \"0\";\n        this.hiddenFileInput.style.width = \"0\";\n        Dropzone.getElement(this.options.hiddenInputContainer, \"hiddenInputContainer\").appendChild(this.hiddenFileInput);\n        this.hiddenFileInput.addEventListener(\"change\", () => {\n          let {\n            files\n          } = this.hiddenFileInput;\n\n          if (files.length) {\n            for (let file of files) {\n              this.addFile(file);\n            }\n          }\n\n          this.emit(\"addedfiles\", files);\n          setupHiddenFileInput();\n        });\n      };\n\n      setupHiddenFileInput();\n    }\n\n    this.URL = window.URL !== null ? window.URL : window.webkitURL; // Setup all event listeners on the Dropzone object itself.\n    // They're not in @setupEventListeners() because they shouldn't be removed\n    // again when the dropzone gets disabled.\n\n    for (let eventName of this.events) {\n      this.on(eventName, this.options[eventName]);\n    }\n\n    this.on(\"uploadprogress\", () => this.updateTotalUploadProgress());\n    this.on(\"removedfile\", () => this.updateTotalUploadProgress());\n    this.on(\"canceled\", file => this.emit(\"complete\", file)); // Emit a `queuecomplete` event if all files finished uploading.\n\n    this.on(\"complete\", file => {\n      if (this.getAddedFiles().length === 0 && this.getUploadingFiles().length === 0 && this.getQueuedFiles().length === 0) {\n        // This needs to be deferred so that `queuecomplete` really triggers after `complete`\n        return setTimeout(() => this.emit(\"queuecomplete\"), 0);\n      }\n    });\n\n    const containsFiles = function (e) {\n      if (e.dataTransfer.types) {\n        // Because e.dataTransfer.types is an Object in\n        // IE, we need to iterate like this instead of\n        // using e.dataTransfer.types.some()\n        for (var i = 0; i < e.dataTransfer.types.length; i++) {\n          if (e.dataTransfer.types[i] === \"Files\") return true;\n        }\n      }\n\n      return false;\n    };\n\n    let noPropagation = function (e) {\n      // If there are no files, we don't want to stop\n      // propagation so we don't interfere with other\n      // drag and drop behaviour.\n      if (!containsFiles(e)) return;\n      e.stopPropagation();\n\n      if (e.preventDefault) {\n        return e.preventDefault();\n      } else {\n        return e.returnValue = false;\n      }\n    }; // Create the listeners\n\n\n    this.listeners = [{\n      element: this.element,\n      events: {\n        dragstart: e => {\n          return this.emit(\"dragstart\", e);\n        },\n        dragenter: e => {\n          noPropagation(e);\n          return this.emit(\"dragenter\", e);\n        },\n        dragover: e => {\n          // Makes it possible to drag files from chrome's download bar\n          // http://stackoverflow.com/questions/19526430/drag-and-drop-file-uploads-from-chrome-downloads-bar\n          // Try is required to prevent bug in Internet Explorer 11 (SCRIPT65535 exception)\n          let efct;\n\n          try {\n            efct = e.dataTransfer.effectAllowed;\n          } catch (error) {}\n\n          e.dataTransfer.dropEffect = \"move\" === efct || \"linkMove\" === efct ? \"move\" : \"copy\";\n          noPropagation(e);\n          return this.emit(\"dragover\", e);\n        },\n        dragleave: e => {\n          return this.emit(\"dragleave\", e);\n        },\n        drop: e => {\n          noPropagation(e);\n          return this.drop(e);\n        },\n        dragend: e => {\n          return this.emit(\"dragend\", e);\n        }\n      } // This is disabled right now, because the browsers don't implement it properly.\n      // \"paste\": (e) =>\n      //   noPropagation e\n      //   @paste e\n\n    }];\n    this.clickableElements.forEach(clickableElement => {\n      return this.listeners.push({\n        element: clickableElement,\n        events: {\n          click: evt => {\n            // Only the actual dropzone or the message element should trigger file selection\n            if (clickableElement !== this.element || evt.target === this.element || Dropzone.elementInside(evt.target, this.element.querySelector(\".dz-message\"))) {\n              this.hiddenFileInput.click(); // Forward the click\n            }\n\n            return true;\n          }\n        }\n      });\n    });\n    this.enable();\n    return this.options.init.call(this);\n  } // Not fully tested yet\n\n\n  destroy() {\n    this.disable();\n    this.removeAllFiles(true);\n\n    if (this.hiddenFileInput != null ? this.hiddenFileInput.parentNode : undefined) {\n      this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);\n      this.hiddenFileInput = null;\n    }\n\n    delete this.element.dropzone;\n    return Dropzone.instances.splice(Dropzone.instances.indexOf(this), 1);\n  }\n\n  updateTotalUploadProgress() {\n    let totalUploadProgress;\n    let totalBytesSent = 0;\n    let totalBytes = 0;\n    let activeFiles = this.getActiveFiles();\n\n    if (activeFiles.length) {\n      for (let file of this.getActiveFiles()) {\n        totalBytesSent += file.upload.bytesSent;\n        totalBytes += file.upload.total;\n      }\n\n      totalUploadProgress = 100 * totalBytesSent / totalBytes;\n    } else {\n      totalUploadProgress = 100;\n    }\n\n    return this.emit(\"totaluploadprogress\", totalUploadProgress, totalBytes, totalBytesSent);\n  } // @options.paramName can be a function taking one parameter rather than a string.\n  // A parameter name for a file is obtained simply by calling this with an index number.\n\n\n  _getParamName(n) {\n    if (typeof this.options.paramName === \"function\") {\n      return this.options.paramName(n);\n    } else {\n      return `${this.options.paramName}${this.options.uploadMultiple ? `[${n}]` : \"\"}`;\n    }\n  } // If @options.renameFile is a function,\n  // the function will be used to rename the file.name before appending it to the formData\n\n\n  _renameFile(file) {\n    if (typeof this.options.renameFile !== \"function\") {\n      return file.name;\n    }\n\n    return this.options.renameFile(file);\n  } // Returns a form that can be used as fallback if the browser does not support DragnDrop\n  //\n  // If the dropzone is already a form, only the input field and button are returned. Otherwise a complete form element is provided.\n  // This code has to pass in IE7 :(\n\n\n  getFallbackForm() {\n    let existingFallback, form;\n\n    if (existingFallback = this.getExistingFallback()) {\n      return existingFallback;\n    }\n\n    let fieldsString = '<div class=\"dz-fallback\">';\n\n    if (this.options.dictFallbackText) {\n      fieldsString += `<p>${this.options.dictFallbackText}</p>`;\n    }\n\n    fieldsString += `<input type=\"file\" name=\"${this._getParamName(0)}\" ${this.options.uploadMultiple ? 'multiple=\"multiple\"' : undefined} /><input type=\"submit\" value=\"Upload!\"></div>`;\n    let fields = Dropzone.createElement(fieldsString);\n\n    if (this.element.tagName !== \"FORM\") {\n      form = Dropzone.createElement(`<form action=\"${this.options.url}\" enctype=\"multipart/form-data\" method=\"${this.options.method}\"></form>`);\n      form.appendChild(fields);\n    } else {\n      // Make sure that the enctype and method attributes are set properly\n      this.element.setAttribute(\"enctype\", \"multipart/form-data\");\n      this.element.setAttribute(\"method\", this.options.method);\n    }\n\n    return form != null ? form : fields;\n  } // Returns the fallback elements if they exist already\n  //\n  // This code has to pass in IE7 :(\n\n\n  getExistingFallback() {\n    let getFallback = function (elements) {\n      for (let el of elements) {\n        if (/(^| )fallback($| )/.test(el.className)) {\n          return el;\n        }\n      }\n    };\n\n    for (let tagName of [\"div\", \"form\"]) {\n      var fallback;\n\n      if (fallback = getFallback(this.element.getElementsByTagName(tagName))) {\n        return fallback;\n      }\n    }\n  } // Activates all listeners stored in @listeners\n\n\n  setupEventListeners() {\n    return this.listeners.map(elementListeners => (() => {\n      let result = [];\n\n      for (let event in elementListeners.events) {\n        let listener = elementListeners.events[event];\n        result.push(elementListeners.element.addEventListener(event, listener, false));\n      }\n\n      return result;\n    })());\n  } // Deactivates all listeners stored in @listeners\n\n\n  removeEventListeners() {\n    return this.listeners.map(elementListeners => (() => {\n      let result = [];\n\n      for (let event in elementListeners.events) {\n        let listener = elementListeners.events[event];\n        result.push(elementListeners.element.removeEventListener(event, listener, false));\n      }\n\n      return result;\n    })());\n  } // Removes all event listeners and cancels all files in the queue or being processed.\n\n\n  disable() {\n    this.clickableElements.forEach(element => element.classList.remove(\"dz-clickable\"));\n    this.removeEventListeners();\n    this.disabled = true;\n    return this.files.map(file => this.cancelUpload(file));\n  }\n\n  enable() {\n    delete this.disabled;\n    this.clickableElements.forEach(element => element.classList.add(\"dz-clickable\"));\n    return this.setupEventListeners();\n  } // Returns a nicely formatted filesize\n\n\n  filesize(size) {\n    let selectedSize = 0;\n    let selectedUnit = \"b\";\n\n    if (size > 0) {\n      let units = [\"tb\", \"gb\", \"mb\", \"kb\", \"b\"];\n\n      for (let i = 0; i < units.length; i++) {\n        let unit = units[i];\n        let cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;\n\n        if (size >= cutoff) {\n          selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);\n          selectedUnit = unit;\n          break;\n        }\n      }\n\n      selectedSize = Math.round(10 * selectedSize) / 10; // Cutting of digits\n    }\n\n    return `<strong>${selectedSize}</strong> ${this.options.dictFileSizeUnits[selectedUnit]}`;\n  } // Adds or removes the `dz-max-files-reached` class from the form.\n\n\n  _updateMaxFilesReachedClass() {\n    if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {\n      if (this.getAcceptedFiles().length === this.options.maxFiles) {\n        this.emit(\"maxfilesreached\", this.files);\n      }\n\n      return this.element.classList.add(\"dz-max-files-reached\");\n    } else {\n      return this.element.classList.remove(\"dz-max-files-reached\");\n    }\n  }\n\n  drop(e) {\n    if (!e.dataTransfer) {\n      return;\n    }\n\n    this.emit(\"drop\", e); // Convert the FileList to an Array\n    // This is necessary for IE11\n\n    let files = [];\n\n    for (let i = 0; i < e.dataTransfer.files.length; i++) {\n      files[i] = e.dataTransfer.files[i];\n    } // Even if it's a folder, files.length will contain the folders.\n\n\n    if (files.length) {\n      let {\n        items\n      } = e.dataTransfer;\n\n      if (items && items.length && items[0].webkitGetAsEntry != null) {\n        // The browser supports dropping of folders, so handle items instead of files\n        this._addFilesFromItems(items);\n      } else {\n        this.handleFiles(files);\n      }\n    }\n\n    this.emit(\"addedfiles\", files);\n  }\n\n  paste(e) {\n    if (__guard__(e != null ? e.clipboardData : undefined, x => x.items) == null) {\n      return;\n    }\n\n    this.emit(\"paste\", e);\n    let {\n      items\n    } = e.clipboardData;\n\n    if (items.length) {\n      return this._addFilesFromItems(items);\n    }\n  }\n\n  handleFiles(files) {\n    for (let file of files) {\n      this.addFile(file);\n    }\n  } // When a folder is dropped (or files are pasted), items must be handled\n  // instead of files.\n\n\n  _addFilesFromItems(items) {\n    return (() => {\n      let result = [];\n\n      for (let item of items) {\n        var entry;\n\n        if (item.webkitGetAsEntry != null && (entry = item.webkitGetAsEntry())) {\n          if (entry.isFile) {\n            result.push(this.addFile(item.getAsFile()));\n          } else if (entry.isDirectory) {\n            // Append all files from that directory to files\n            result.push(this._addFilesFromDirectory(entry, entry.name));\n          } else {\n            result.push(undefined);\n          }\n        } else if (item.getAsFile != null) {\n          if (item.kind == null || item.kind === \"file\") {\n            result.push(this.addFile(item.getAsFile()));\n          } else {\n            result.push(undefined);\n          }\n        } else {\n          result.push(undefined);\n        }\n      }\n\n      return result;\n    })();\n  } // Goes through the directory, and adds each file it finds recursively\n\n\n  _addFilesFromDirectory(directory, path) {\n    let dirReader = directory.createReader();\n\n    let errorHandler = error => __guardMethod__(console, \"log\", o => o.log(error));\n\n    var readEntries = () => {\n      return dirReader.readEntries(entries => {\n        if (entries.length > 0) {\n          for (let entry of entries) {\n            if (entry.isFile) {\n              entry.file(file => {\n                if (this.options.ignoreHiddenFiles && file.name.substring(0, 1) === \".\") {\n                  return;\n                }\n\n                file.fullPath = `${path}/${file.name}`;\n                return this.addFile(file);\n              });\n            } else if (entry.isDirectory) {\n              this._addFilesFromDirectory(entry, `${path}/${entry.name}`);\n            }\n          } // Recursively call readEntries() again, since browser only handle\n          // the first 100 entries.\n          // See: https://developer.mozilla.org/en-US/docs/Web/API/DirectoryReader#readEntries\n\n\n          readEntries();\n        }\n\n        return null;\n      }, errorHandler);\n    };\n\n    return readEntries();\n  } // If `done()` is called without argument the file is accepted\n  // If you call it with an error message, the file is rejected\n  // (This allows for asynchronous validation)\n  //\n  // This function checks the filesize, and if the file.type passes the\n  // `acceptedFiles` check.\n\n\n  accept(file, done) {\n    if (this.options.maxFilesize && file.size > this.options.maxFilesize * 1024 * 1024) {\n      done(this.options.dictFileTooBig.replace(\"{{filesize}}\", Math.round(file.size / 1024 / 10.24) / 100).replace(\"{{maxFilesize}}\", this.options.maxFilesize));\n    } else if (!Dropzone.isValidFile(file, this.options.acceptedFiles)) {\n      done(this.options.dictInvalidFileType);\n    } else if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {\n      done(this.options.dictMaxFilesExceeded.replace(\"{{maxFiles}}\", this.options.maxFiles));\n      this.emit(\"maxfilesexceeded\", file);\n    } else {\n      this.options.accept.call(this, file, done);\n    }\n  }\n\n  addFile(file) {\n    file.upload = {\n      uuid: Dropzone.uuidv4(),\n      progress: 0,\n      // Setting the total upload size to file.size for the beginning\n      // It's actual different than the size to be transmitted.\n      total: file.size,\n      bytesSent: 0,\n      filename: this._renameFile(file) // Not setting chunking information here, because the acutal data — and\n      // thus the chunks — might change if `options.transformFile` is set\n      // and does something to the data.\n\n    };\n    this.files.push(file);\n    file.status = Dropzone.ADDED;\n    this.emit(\"addedfile\", file);\n\n    this._enqueueThumbnail(file);\n\n    this.accept(file, error => {\n      if (error) {\n        file.accepted = false;\n\n        this._errorProcessing([file], error); // Will set the file.status\n\n      } else {\n        file.accepted = true;\n\n        if (this.options.autoQueue) {\n          this.enqueueFile(file);\n        } // Will set .accepted = true\n\n      }\n\n      this._updateMaxFilesReachedClass();\n    });\n  } // Wrapper for enqueueFile\n\n\n  enqueueFiles(files) {\n    for (let file of files) {\n      this.enqueueFile(file);\n    }\n\n    return null;\n  }\n\n  enqueueFile(file) {\n    if (file.status === Dropzone.ADDED && file.accepted === true) {\n      file.status = Dropzone.QUEUED;\n\n      if (this.options.autoProcessQueue) {\n        return setTimeout(() => this.processQueue(), 0); // Deferring the call\n      }\n    } else {\n      throw new Error(\"This file can't be queued because it has already been processed or was rejected.\");\n    }\n  }\n\n  _enqueueThumbnail(file) {\n    if (this.options.createImageThumbnails && file.type.match(/image.*/) && file.size <= this.options.maxThumbnailFilesize * 1024 * 1024) {\n      this._thumbnailQueue.push(file);\n\n      return setTimeout(() => this._processThumbnailQueue(), 0); // Deferring the call\n    }\n  }\n\n  _processThumbnailQueue() {\n    if (this._processingThumbnail || this._thumbnailQueue.length === 0) {\n      return;\n    }\n\n    this._processingThumbnail = true;\n\n    let file = this._thumbnailQueue.shift();\n\n    return this.createThumbnail(file, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, true, dataUrl => {\n      this.emit(\"thumbnail\", file, dataUrl);\n      this._processingThumbnail = false;\n      return this._processThumbnailQueue();\n    });\n  } // Can be called by the user to remove a file\n\n\n  removeFile(file) {\n    if (file.status === Dropzone.UPLOADING) {\n      this.cancelUpload(file);\n    }\n\n    this.files = without(this.files, file);\n    this.emit(\"removedfile\", file);\n\n    if (this.files.length === 0) {\n      return this.emit(\"reset\");\n    }\n  } // Removes all files that aren't currently processed from the list\n\n\n  removeAllFiles(cancelIfNecessary) {\n    // Create a copy of files since removeFile() changes the @files array.\n    if (cancelIfNecessary == null) {\n      cancelIfNecessary = false;\n    }\n\n    for (let file of this.files.slice()) {\n      if (file.status !== Dropzone.UPLOADING || cancelIfNecessary) {\n        this.removeFile(file);\n      }\n    }\n\n    return null;\n  } // Resizes an image before it gets sent to the server. This function is the default behavior of\n  // `options.transformFile` if `resizeWidth` or `resizeHeight` are set. The callback is invoked with\n  // the resized blob.\n\n\n  resizeImage(file, width, height, resizeMethod, callback) {\n    return this.createThumbnail(file, width, height, resizeMethod, true, (dataUrl, canvas) => {\n      if (canvas == null) {\n        // The image has not been resized\n        return callback(file);\n      } else {\n        let {\n          resizeMimeType\n        } = this.options;\n\n        if (resizeMimeType == null) {\n          resizeMimeType = file.type;\n        }\n\n        let resizedDataURL = canvas.toDataURL(resizeMimeType, this.options.resizeQuality);\n\n        if (resizeMimeType === \"image/jpeg\" || resizeMimeType === \"image/jpg\") {\n          // Now add the original EXIF information\n          resizedDataURL = ExifRestore.restore(file.dataURL, resizedDataURL);\n        }\n\n        return callback(Dropzone.dataURItoBlob(resizedDataURL));\n      }\n    });\n  }\n\n  createThumbnail(file, width, height, resizeMethod, fixOrientation, callback) {\n    let fileReader = new FileReader();\n\n    fileReader.onload = () => {\n      file.dataURL = fileReader.result; // Don't bother creating a thumbnail for SVG images since they're vector\n\n      if (file.type === \"image/svg+xml\") {\n        if (callback != null) {\n          callback(fileReader.result);\n        }\n\n        return;\n      }\n\n      this.createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback);\n    };\n\n    fileReader.readAsDataURL(file);\n  } // `mockFile` needs to have these attributes:\n  //\n  //     { name: 'name', size: 12345, imageUrl: '' }\n  //\n  // `callback` will be invoked when the image has been downloaded and displayed.\n  // `crossOrigin` will be added to the `img` tag when accessing the file.\n\n\n  displayExistingFile(mockFile, imageUrl, callback, crossOrigin, resizeThumbnail = true) {\n    this.emit(\"addedfile\", mockFile);\n    this.emit(\"complete\", mockFile);\n\n    if (!resizeThumbnail) {\n      this.emit(\"thumbnail\", mockFile, imageUrl);\n      if (callback) callback();\n    } else {\n      let onDone = thumbnail => {\n        this.emit(\"thumbnail\", mockFile, thumbnail);\n        if (callback) callback();\n      };\n\n      mockFile.dataURL = imageUrl;\n      this.createThumbnailFromUrl(mockFile, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.resizeMethod, this.options.fixOrientation, onDone, crossOrigin);\n    }\n  }\n\n  createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback, crossOrigin) {\n    // Not using `new Image` here because of a bug in latest Chrome versions.\n    // See https://github.com/enyo/dropzone/pull/226\n    let img = document.createElement(\"img\");\n\n    if (crossOrigin) {\n      img.crossOrigin = crossOrigin;\n    } // fixOrientation is not needed anymore with browsers handling imageOrientation\n\n\n    fixOrientation = getComputedStyle(document.body)[\"imageOrientation\"] == \"from-image\" ? false : fixOrientation;\n\n    img.onload = () => {\n      let loadExif = callback => callback(1);\n\n      if (typeof EXIF !== \"undefined\" && EXIF !== null && fixOrientation) {\n        loadExif = callback => EXIF.getData(img, function () {\n          return callback(EXIF.getTag(this, \"Orientation\"));\n        });\n      }\n\n      return loadExif(orientation => {\n        file.width = img.width;\n        file.height = img.height;\n        let resizeInfo = this.options.resize.call(this, file, width, height, resizeMethod);\n        let canvas = document.createElement(\"canvas\");\n        let ctx = canvas.getContext(\"2d\");\n        canvas.width = resizeInfo.trgWidth;\n        canvas.height = resizeInfo.trgHeight;\n\n        if (orientation > 4) {\n          canvas.width = resizeInfo.trgHeight;\n          canvas.height = resizeInfo.trgWidth;\n        }\n\n        switch (orientation) {\n          case 2:\n            // horizontal flip\n            ctx.translate(canvas.width, 0);\n            ctx.scale(-1, 1);\n            break;\n\n          case 3:\n            // 180° rotate left\n            ctx.translate(canvas.width, canvas.height);\n            ctx.rotate(Math.PI);\n            break;\n\n          case 4:\n            // vertical flip\n            ctx.translate(0, canvas.height);\n            ctx.scale(1, -1);\n            break;\n\n          case 5:\n            // vertical flip + 90 rotate right\n            ctx.rotate(0.5 * Math.PI);\n            ctx.scale(1, -1);\n            break;\n\n          case 6:\n            // 90° rotate right\n            ctx.rotate(0.5 * Math.PI);\n            ctx.translate(0, -canvas.width);\n            break;\n\n          case 7:\n            // horizontal flip + 90 rotate right\n            ctx.rotate(0.5 * Math.PI);\n            ctx.translate(canvas.height, -canvas.width);\n            ctx.scale(-1, 1);\n            break;\n\n          case 8:\n            // 90° rotate left\n            ctx.rotate(-0.5 * Math.PI);\n            ctx.translate(-canvas.height, 0);\n            break;\n        } // This is a bugfix for iOS' scaling bug.\n\n\n        drawImageIOSFix(ctx, img, resizeInfo.srcX != null ? resizeInfo.srcX : 0, resizeInfo.srcY != null ? resizeInfo.srcY : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, resizeInfo.trgX != null ? resizeInfo.trgX : 0, resizeInfo.trgY != null ? resizeInfo.trgY : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);\n        let thumbnail = canvas.toDataURL(\"image/png\");\n\n        if (callback != null) {\n          return callback(thumbnail, canvas);\n        }\n      });\n    };\n\n    if (callback != null) {\n      img.onerror = callback;\n    }\n\n    return img.src = file.dataURL;\n  } // Goes through the queue and processes files if there aren't too many already.\n\n\n  processQueue() {\n    let {\n      parallelUploads\n    } = this.options;\n    let processingLength = this.getUploadingFiles().length;\n    let i = processingLength; // There are already at least as many files uploading than should be\n\n    if (processingLength >= parallelUploads) {\n      return;\n    }\n\n    let queuedFiles = this.getQueuedFiles();\n\n    if (!(queuedFiles.length > 0)) {\n      return;\n    }\n\n    if (this.options.uploadMultiple) {\n      // The files should be uploaded in one request\n      return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));\n    } else {\n      while (i < parallelUploads) {\n        if (!queuedFiles.length) {\n          return;\n        } // Nothing left to process\n\n\n        this.processFile(queuedFiles.shift());\n        i++;\n      }\n    }\n  } // Wrapper for `processFiles`\n\n\n  processFile(file) {\n    return this.processFiles([file]);\n  } // Loads the file, then calls finishedLoading()\n\n\n  processFiles(files) {\n    for (let file of files) {\n      file.processing = true; // Backwards compatibility\n\n      file.status = Dropzone.UPLOADING;\n      this.emit(\"processing\", file);\n    }\n\n    if (this.options.uploadMultiple) {\n      this.emit(\"processingmultiple\", files);\n    }\n\n    return this.uploadFiles(files);\n  }\n\n  _getFilesWithXhr(xhr) {\n    let files;\n    return files = this.files.filter(file => file.xhr === xhr).map(file => file);\n  } // Cancels the file upload and sets the status to CANCELED\n  // **if** the file is actually being uploaded.\n  // If it's still in the queue, the file is being removed from it and the status\n  // set to CANCELED.\n\n\n  cancelUpload(file) {\n    if (file.status === Dropzone.UPLOADING) {\n      let groupedFiles = this._getFilesWithXhr(file.xhr);\n\n      for (let groupedFile of groupedFiles) {\n        groupedFile.status = Dropzone.CANCELED;\n      }\n\n      if (typeof file.xhr !== \"undefined\") {\n        file.xhr.abort();\n      }\n\n      for (let groupedFile of groupedFiles) {\n        this.emit(\"canceled\", groupedFile);\n      }\n\n      if (this.options.uploadMultiple) {\n        this.emit(\"canceledmultiple\", groupedFiles);\n      }\n    } else if (file.status === Dropzone.ADDED || file.status === Dropzone.QUEUED) {\n      file.status = Dropzone.CANCELED;\n      this.emit(\"canceled\", file);\n\n      if (this.options.uploadMultiple) {\n        this.emit(\"canceledmultiple\", [file]);\n      }\n    }\n\n    if (this.options.autoProcessQueue) {\n      return this.processQueue();\n    }\n  }\n\n  resolveOption(option, ...args) {\n    if (typeof option === \"function\") {\n      return option.apply(this, args);\n    }\n\n    return option;\n  }\n\n  uploadFile(file) {\n    return this.uploadFiles([file]);\n  }\n\n  uploadFiles(files) {\n    this._transformFiles(files, transformedFiles => {\n      if (this.options.chunking) {\n        // Chunking is not allowed to be used with `uploadMultiple` so we know\n        // that there is only __one__file.\n        let transformedFile = transformedFiles[0];\n        files[0].upload.chunked = this.options.chunking && (this.options.forceChunking || transformedFile.size > this.options.chunkSize);\n        files[0].upload.totalChunkCount = Math.ceil(transformedFile.size / this.options.chunkSize);\n      }\n\n      if (files[0].upload.chunked) {\n        // This file should be sent in chunks!\n        // If the chunking option is set, we **know** that there can only be **one** file, since\n        // uploadMultiple is not allowed with this option.\n        let file = files[0];\n        let transformedFile = transformedFiles[0];\n        let startedChunkCount = 0;\n        file.upload.chunks = [];\n\n        let handleNextChunk = () => {\n          let chunkIndex = 0; // Find the next item in file.upload.chunks that is not defined yet.\n\n          while (file.upload.chunks[chunkIndex] !== undefined) {\n            chunkIndex++;\n          } // This means, that all chunks have already been started.\n\n\n          if (chunkIndex >= file.upload.totalChunkCount) return;\n          startedChunkCount++;\n          let start = chunkIndex * this.options.chunkSize;\n          let end = Math.min(start + this.options.chunkSize, transformedFile.size);\n          let dataBlock = {\n            name: this._getParamName(0),\n            data: transformedFile.webkitSlice ? transformedFile.webkitSlice(start, end) : transformedFile.slice(start, end),\n            filename: file.upload.filename,\n            chunkIndex: chunkIndex\n          };\n          file.upload.chunks[chunkIndex] = {\n            file: file,\n            index: chunkIndex,\n            dataBlock: dataBlock,\n            // In case we want to retry.\n            status: Dropzone.UPLOADING,\n            progress: 0,\n            retries: 0 // The number of times this block has been retried.\n\n          };\n\n          this._uploadData(files, [dataBlock]);\n        };\n\n        file.upload.finishedChunkUpload = (chunk, response) => {\n          let allFinished = true;\n          chunk.status = Dropzone.SUCCESS; // Clear the data from the chunk\n\n          chunk.dataBlock = null; // Leaving this reference to xhr intact here will cause memory leaks in some browsers\n\n          chunk.xhr = null;\n\n          for (let i = 0; i < file.upload.totalChunkCount; i++) {\n            if (file.upload.chunks[i] === undefined) {\n              return handleNextChunk();\n            }\n\n            if (file.upload.chunks[i].status !== Dropzone.SUCCESS) {\n              allFinished = false;\n            }\n          }\n\n          if (allFinished) {\n            this.options.chunksUploaded(file, () => {\n              this._finished(files, response, null);\n            });\n          }\n        };\n\n        if (this.options.parallelChunkUploads) {\n          for (let i = 0; i < file.upload.totalChunkCount; i++) {\n            handleNextChunk();\n          }\n        } else {\n          handleNextChunk();\n        }\n      } else {\n        let dataBlocks = [];\n\n        for (let i = 0; i < files.length; i++) {\n          dataBlocks[i] = {\n            name: this._getParamName(i),\n            data: transformedFiles[i],\n            filename: files[i].upload.filename\n          };\n        }\n\n        this._uploadData(files, dataBlocks);\n      }\n    });\n  } /// Returns the right chunk for given file and xhr\n\n\n  _getChunk(file, xhr) {\n    for (let i = 0; i < file.upload.totalChunkCount; i++) {\n      if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].xhr === xhr) {\n        return file.upload.chunks[i];\n      }\n    }\n  } // This function actually uploads the file(s) to the server.\n  // If dataBlocks contains the actual data to upload (meaning, that this could either be transformed\n  // files, or individual chunks for chunked upload).\n\n\n  _uploadData(files, dataBlocks) {\n    let xhr = new XMLHttpRequest(); // Put the xhr object in the file objects to be able to reference it later.\n\n    for (let file of files) {\n      file.xhr = xhr;\n    }\n\n    if (files[0].upload.chunked) {\n      // Put the xhr object in the right chunk object, so it can be associated later, and found with _getChunk\n      files[0].upload.chunks[dataBlocks[0].chunkIndex].xhr = xhr;\n    }\n\n    let method = this.resolveOption(this.options.method, files);\n    let url = this.resolveOption(this.options.url, files);\n    xhr.open(method, url, true); // Setting the timeout after open because of IE11 issue: https://gitlab.com/meno/dropzone/issues/8\n\n    let timeout = this.resolveOption(this.options.timeout, files);\n    if (timeout) xhr.timeout = this.resolveOption(this.options.timeout, files); // Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179\n\n    xhr.withCredentials = !!this.options.withCredentials;\n\n    xhr.onload = e => {\n      this._finishedUploading(files, xhr, e);\n    };\n\n    xhr.ontimeout = () => {\n      this._handleUploadError(files, xhr, `Request timedout after ${this.options.timeout / 1000} seconds`);\n    };\n\n    xhr.onerror = () => {\n      this._handleUploadError(files, xhr);\n    }; // Some browsers do not have the .upload property\n\n\n    let progressObj = xhr.upload != null ? xhr.upload : xhr;\n\n    progressObj.onprogress = e => this._updateFilesUploadProgress(files, xhr, e);\n\n    let headers = {\n      Accept: \"application/json\",\n      \"Cache-Control\": \"no-cache\",\n      \"X-Requested-With\": \"XMLHttpRequest\"\n    };\n\n    if (this.options.headers) {\n      Dropzone.extend(headers, this.options.headers);\n    }\n\n    for (let headerName in headers) {\n      let headerValue = headers[headerName];\n\n      if (headerValue) {\n        xhr.setRequestHeader(headerName, headerValue);\n      }\n    }\n\n    let formData = new FormData(); // Adding all @options parameters\n\n    if (this.options.params) {\n      let additionalParams = this.options.params;\n\n      if (typeof additionalParams === \"function\") {\n        additionalParams = additionalParams.call(this, files, xhr, files[0].upload.chunked ? this._getChunk(files[0], xhr) : null);\n      }\n\n      for (let key in additionalParams) {\n        let value = additionalParams[key];\n\n        if (Array.isArray(value)) {\n          // The additional parameter contains an array,\n          // so lets iterate over it to attach each value\n          // individually.\n          for (let i = 0; i < value.length; i++) {\n            formData.append(key, value[i]);\n          }\n        } else {\n          formData.append(key, value);\n        }\n      }\n    } // Let the user add additional data if necessary\n\n\n    for (let file of files) {\n      this.emit(\"sending\", file, xhr, formData);\n    }\n\n    if (this.options.uploadMultiple) {\n      this.emit(\"sendingmultiple\", files, xhr, formData);\n    }\n\n    this._addFormElementData(formData); // Finally add the files\n    // Has to be last because some servers (eg: S3) expect the file to be the last parameter\n\n\n    for (let i = 0; i < dataBlocks.length; i++) {\n      let dataBlock = dataBlocks[i];\n      formData.append(dataBlock.name, dataBlock.data, dataBlock.filename);\n    }\n\n    this.submitRequest(xhr, formData, files);\n  } // Transforms all files with this.options.transformFile and invokes done with the transformed files when done.\n\n\n  _transformFiles(files, done) {\n    let transformedFiles = []; // Clumsy way of handling asynchronous calls, until I get to add a proper Future library.\n\n    let doneCounter = 0;\n\n    for (let i = 0; i < files.length; i++) {\n      this.options.transformFile.call(this, files[i], transformedFile => {\n        transformedFiles[i] = transformedFile;\n\n        if (++doneCounter === files.length) {\n          done(transformedFiles);\n        }\n      });\n    }\n  } // Takes care of adding other input elements of the form to the AJAX request\n\n\n  _addFormElementData(formData) {\n    // Take care of other input elements\n    if (this.element.tagName === \"FORM\") {\n      for (let input of this.element.querySelectorAll(\"input, textarea, select, button\")) {\n        let inputName = input.getAttribute(\"name\");\n        let inputType = input.getAttribute(\"type\");\n        if (inputType) inputType = inputType.toLowerCase(); // If the input doesn't have a name, we can't use it.\n\n        if (typeof inputName === \"undefined\" || inputName === null) continue;\n\n        if (input.tagName === \"SELECT\" && input.hasAttribute(\"multiple\")) {\n          // Possibly multiple values\n          for (let option of input.options) {\n            if (option.selected) {\n              formData.append(inputName, option.value);\n            }\n          }\n        } else if (!inputType || inputType !== \"checkbox\" && inputType !== \"radio\" || input.checked) {\n          formData.append(inputName, input.value);\n        }\n      }\n    }\n  } // Invoked when there is new progress information about given files.\n  // If e is not provided, it is assumed that the upload is finished.\n\n\n  _updateFilesUploadProgress(files, xhr, e) {\n    if (!files[0].upload.chunked) {\n      // Handle file uploads without chunking\n      for (let file of files) {\n        if (file.upload.total && file.upload.bytesSent && file.upload.bytesSent == file.upload.total) {\n          // If both, the `total` and `bytesSent` have already been set, and\n          // they are equal (meaning progress is at 100%), we can skip this\n          // file, since an upload progress shouldn't go down.\n          continue;\n        }\n\n        if (e) {\n          file.upload.progress = 100 * e.loaded / e.total;\n          file.upload.total = e.total;\n          file.upload.bytesSent = e.loaded;\n        } else {\n          // No event, so we're at 100%\n          file.upload.progress = 100;\n          file.upload.bytesSent = file.upload.total;\n        }\n\n        this.emit(\"uploadprogress\", file, file.upload.progress, file.upload.bytesSent);\n      }\n    } else {\n      // Handle chunked file uploads\n      // Chunked upload is not compatible with uploading multiple files in one\n      // request, so we know there's only one file.\n      let file = files[0]; // Since this is a chunked upload, we need to update the appropriate chunk\n      // progress.\n\n      let chunk = this._getChunk(file, xhr);\n\n      if (e) {\n        chunk.progress = 100 * e.loaded / e.total;\n        chunk.total = e.total;\n        chunk.bytesSent = e.loaded;\n      } else {\n        // No event, so we're at 100%\n        chunk.progress = 100;\n        chunk.bytesSent = chunk.total;\n      } // Now tally the *file* upload progress from its individual chunks\n\n\n      file.upload.progress = 0;\n      file.upload.total = 0;\n      file.upload.bytesSent = 0;\n\n      for (let i = 0; i < file.upload.totalChunkCount; i++) {\n        if (file.upload.chunks[i] && typeof file.upload.chunks[i].progress !== \"undefined\") {\n          file.upload.progress += file.upload.chunks[i].progress;\n          file.upload.total += file.upload.chunks[i].total;\n          file.upload.bytesSent += file.upload.chunks[i].bytesSent;\n        }\n      } // Since the process is a percentage, we need to divide by the amount of\n      // chunks we've used.\n\n\n      file.upload.progress = file.upload.progress / file.upload.totalChunkCount;\n      this.emit(\"uploadprogress\", file, file.upload.progress, file.upload.bytesSent);\n    }\n  }\n\n  _finishedUploading(files, xhr, e) {\n    let response;\n\n    if (files[0].status === Dropzone.CANCELED) {\n      return;\n    }\n\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    if (xhr.responseType !== \"arraybuffer\" && xhr.responseType !== \"blob\") {\n      response = xhr.responseText;\n\n      if (xhr.getResponseHeader(\"content-type\") && ~xhr.getResponseHeader(\"content-type\").indexOf(\"application/json\")) {\n        try {\n          response = JSON.parse(response);\n        } catch (error) {\n          e = error;\n          response = \"Invalid JSON response from server.\";\n        }\n      }\n    }\n\n    this._updateFilesUploadProgress(files, xhr);\n\n    if (!(200 <= xhr.status && xhr.status < 300)) {\n      this._handleUploadError(files, xhr, response);\n    } else {\n      if (files[0].upload.chunked) {\n        files[0].upload.finishedChunkUpload(this._getChunk(files[0], xhr), response);\n      } else {\n        this._finished(files, response, e);\n      }\n    }\n  }\n\n  _handleUploadError(files, xhr, response) {\n    if (files[0].status === Dropzone.CANCELED) {\n      return;\n    }\n\n    if (files[0].upload.chunked && this.options.retryChunks) {\n      let chunk = this._getChunk(files[0], xhr);\n\n      if (chunk.retries++ < this.options.retryChunksLimit) {\n        this._uploadData(files, [chunk.dataBlock]);\n\n        return;\n      } else {\n        console.warn(\"Retried this chunk too often. Giving up.\");\n      }\n    }\n\n    this._errorProcessing(files, response || this.options.dictResponseError.replace(\"{{statusCode}}\", xhr.status), xhr);\n  }\n\n  submitRequest(xhr, formData, files) {\n    if (xhr.readyState != 1) {\n      console.warn(\"Cannot send this request because the XMLHttpRequest.readyState is not OPENED.\");\n      return;\n    }\n\n    xhr.send(formData);\n  } // Called internally when processing is finished.\n  // Individual callbacks have to be called in the appropriate sections.\n\n\n  _finished(files, responseText, e) {\n    for (let file of files) {\n      file.status = Dropzone.SUCCESS;\n      this.emit(\"success\", file, responseText, e);\n      this.emit(\"complete\", file);\n    }\n\n    if (this.options.uploadMultiple) {\n      this.emit(\"successmultiple\", files, responseText, e);\n      this.emit(\"completemultiple\", files);\n    }\n\n    if (this.options.autoProcessQueue) {\n      return this.processQueue();\n    }\n  } // Called internally when processing is finished.\n  // Individual callbacks have to be called in the appropriate sections.\n\n\n  _errorProcessing(files, message, xhr) {\n    for (let file of files) {\n      file.status = Dropzone.ERROR;\n      this.emit(\"error\", file, message, xhr);\n      this.emit(\"complete\", file);\n    }\n\n    if (this.options.uploadMultiple) {\n      this.emit(\"errormultiple\", files, message, xhr);\n      this.emit(\"completemultiple\", files);\n    }\n\n    if (this.options.autoProcessQueue) {\n      return this.processQueue();\n    }\n  }\n\n  static uuidv4() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n      let r = Math.random() * 16 | 0,\n          v = c === \"x\" ? r : r & 0x3 | 0x8;\n      return v.toString(16);\n    });\n  }\n\n}\nDropzone.initClass();\nDropzone.version = \"dev\"; // This is a map of options for your different dropzones. Add configurations\n// to this object for your different dropzone elemens.\n//\n// Example:\n//\n//     Dropzone.options.myDropzoneElementId = { maxFilesize: 1 };\n//\n// To disable autoDiscover for a specific element, you can set `false` as an option:\n//\n//     Dropzone.options.myDisabledElementId = false;\n//\n// And in html:\n//\n//     <form action=\"/upload\" id=\"my-dropzone-element-id\" class=\"dropzone\"></form>\n\nDropzone.options = {}; // Returns the options for an element or undefined if none available.\n\nDropzone.optionsForElement = function (element) {\n  // Get the `Dropzone.options.elementId` for this element if it exists\n  if (element.getAttribute(\"id\")) {\n    return Dropzone.options[camelize(element.getAttribute(\"id\"))];\n  } else {\n    return undefined;\n  }\n}; // Holds a list of all dropzone instances\n\n\nDropzone.instances = []; // Returns the dropzone for given element if any\n\nDropzone.forElement = function (element) {\n  if (typeof element === \"string\") {\n    element = document.querySelector(element);\n  }\n\n  if ((element != null ? element.dropzone : undefined) == null) {\n    throw new Error(\"No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.\");\n  }\n\n  return element.dropzone;\n}; // Set to false if you don't want Dropzone to automatically find and attach to .dropzone elements.\n\n\nDropzone.autoDiscover = true; // Looks for all .dropzone elements and creates a dropzone for them\n\nDropzone.discover = function () {\n  let dropzones;\n\n  if (document.querySelectorAll) {\n    dropzones = document.querySelectorAll(\".dropzone\");\n  } else {\n    dropzones = []; // IE :(\n\n    let checkElements = elements => (() => {\n      let result = [];\n\n      for (let el of elements) {\n        if (/(^| )dropzone($| )/.test(el.className)) {\n          result.push(dropzones.push(el));\n        } else {\n          result.push(undefined);\n        }\n      }\n\n      return result;\n    })();\n\n    checkElements(document.getElementsByTagName(\"div\"));\n    checkElements(document.getElementsByTagName(\"form\"));\n  }\n\n  return (() => {\n    let result = [];\n\n    for (let dropzone of dropzones) {\n      // Create a dropzone unless auto discover has been disabled for specific element\n      if (Dropzone.optionsForElement(dropzone) !== false) {\n        result.push(new Dropzone(dropzone));\n      } else {\n        result.push(undefined);\n      }\n    }\n\n    return result;\n  })();\n}; // Some browsers support drag and drog functionality, but not correctly.\n//\n// So I created a blocklist of userAgents. Yes, yes. Browser sniffing, I know.\n// But what to do when browsers *theoretically* support an API, but crash\n// when using it.\n//\n// This is a list of regular expressions tested against navigator.userAgent\n//\n// ** It should only be used on browser that *do* support the API, but\n// incorrectly **\n\n\nDropzone.blockedBrowsers = [// The mac os and windows phone version of opera 12 seems to have a problem with the File drag'n'drop API.\n/opera.*(Macintosh|Windows Phone).*version\\/12/i]; // Checks if the browser is supported\n\nDropzone.isBrowserSupported = function () {\n  let capableBrowser = true;\n\n  if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {\n    if (!(\"classList\" in document.createElement(\"a\"))) {\n      capableBrowser = false;\n    } else {\n      if (Dropzone.blacklistedBrowsers !== undefined) {\n        // Since this has been renamed, this makes sure we don't break older\n        // configuration.\n        Dropzone.blockedBrowsers = Dropzone.blacklistedBrowsers;\n      } // The browser supports the API, but may be blocked.\n\n\n      for (let regex of Dropzone.blockedBrowsers) {\n        if (regex.test(navigator.userAgent)) {\n          capableBrowser = false;\n          continue;\n        }\n      }\n    }\n  } else {\n    capableBrowser = false;\n  }\n\n  return capableBrowser;\n};\n\nDropzone.dataURItoBlob = function (dataURI) {\n  // convert base64 to raw binary data held in a string\n  // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this\n  let byteString = atob(dataURI.split(\",\")[1]); // separate out the mime component\n\n  let mimeString = dataURI.split(\",\")[0].split(\":\")[1].split(\";\")[0]; // write the bytes of the string to an ArrayBuffer\n\n  let ab = new ArrayBuffer(byteString.length);\n  let ia = new Uint8Array(ab);\n\n  for (let i = 0, end = byteString.length, asc = 0 <= end; asc ? i <= end : i >= end; asc ? i++ : i--) {\n    ia[i] = byteString.charCodeAt(i);\n  } // write the ArrayBuffer to a blob\n\n\n  return new Blob([ab], {\n    type: mimeString\n  });\n}; // Returns an array without the rejected item\n\n\nconst without = (list, rejectedItem) => list.filter(item => item !== rejectedItem).map(item => item); // abc-def_ghi -> abcDefGhi\n\n\nconst camelize = str => str.replace(/[\\-_](\\w)/g, match => match.charAt(1).toUpperCase()); // Creates an element from string\n\n\nDropzone.createElement = function (string) {\n  let div = document.createElement(\"div\");\n  div.innerHTML = string;\n  return div.childNodes[0];\n}; // Tests if given element is inside (or simply is) the container\n\n\nDropzone.elementInside = function (element, container) {\n  if (element === container) {\n    return true;\n  } // Coffeescript doesn't support do/while loops\n\n\n  while (element = element.parentNode) {\n    if (element === container) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nDropzone.getElement = function (el, name) {\n  let element;\n\n  if (typeof el === \"string\") {\n    element = document.querySelector(el);\n  } else if (el.nodeType != null) {\n    element = el;\n  }\n\n  if (element == null) {\n    throw new Error(`Invalid \\`${name}\\` option provided. Please provide a CSS selector or a plain HTML element.`);\n  }\n\n  return element;\n};\n\nDropzone.getElements = function (els, name) {\n  let el, elements;\n\n  if (els instanceof Array) {\n    elements = [];\n\n    try {\n      for (el of els) {\n        elements.push(this.getElement(el, name));\n      }\n    } catch (e) {\n      elements = null;\n    }\n  } else if (typeof els === \"string\") {\n    elements = [];\n\n    for (el of document.querySelectorAll(els)) {\n      elements.push(el);\n    }\n  } else if (els.nodeType != null) {\n    elements = [els];\n  }\n\n  if (elements == null || !elements.length) {\n    throw new Error(`Invalid \\`${name}\\` option provided. Please provide a CSS selector, a plain HTML element or a list of those.`);\n  }\n\n  return elements;\n}; // Asks the user the question and calls accepted or rejected accordingly\n//\n// The default implementation just uses `window.confirm` and then calls the\n// appropriate callback.\n\n\nDropzone.confirm = function (question, accepted, rejected) {\n  if (window.confirm(question)) {\n    return accepted();\n  } else if (rejected != null) {\n    return rejected();\n  }\n}; // Validates the mime type like this:\n//\n// https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept\n\n\nDropzone.isValidFile = function (file, acceptedFiles) {\n  if (!acceptedFiles) {\n    return true;\n  } // If there are no accepted mime types, it's OK\n\n\n  acceptedFiles = acceptedFiles.split(\",\");\n  let mimeType = file.type;\n  let baseMimeType = mimeType.replace(/\\/.*$/, \"\");\n\n  for (let validType of acceptedFiles) {\n    validType = validType.trim();\n\n    if (validType.charAt(0) === \".\") {\n      if (file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.length - validType.length) !== -1) {\n        return true;\n      }\n    } else if (/\\/\\*$/.test(validType)) {\n      // This is something like a image/* mime type\n      if (baseMimeType === validType.replace(/\\/.*$/, \"\")) {\n        return true;\n      }\n    } else {\n      if (mimeType === validType) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // Augment jQuery\n\n\nif (typeof jQuery !== \"undefined\" && jQuery !== null) {\n  jQuery.fn.dropzone = function (options) {\n    return this.each(function () {\n      return new Dropzone(this, options);\n    });\n  };\n} // Dropzone file status codes\n\n\nDropzone.ADDED = \"added\";\nDropzone.QUEUED = \"queued\"; // For backwards compatibility. Now, if a file is accepted, it's either queued\n// or uploading.\n\nDropzone.ACCEPTED = Dropzone.QUEUED;\nDropzone.UPLOADING = \"uploading\";\nDropzone.PROCESSING = Dropzone.UPLOADING; // alias\n\nDropzone.CANCELED = \"canceled\";\nDropzone.ERROR = \"error\";\nDropzone.SUCCESS = \"success\";\n/*\n\n Bugfix for iOS 6 and 7\n Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios\n based on the work of https://github.com/stomita/ios-imagefile-megapixel\n\n */\n// Detecting vertical squash in loaded image.\n// Fixes a bug which squash image vertically while drawing into canvas for some images.\n// This is a bug in iOS6 devices. This function from https://github.com/stomita/ios-imagefile-megapixel\n\nlet detectVerticalSquash = function (img) {\n  let iw = img.naturalWidth;\n  let ih = img.naturalHeight;\n  let canvas = document.createElement(\"canvas\");\n  canvas.width = 1;\n  canvas.height = ih;\n  let ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(img, 0, 0);\n  let {\n    data\n  } = ctx.getImageData(1, 0, 1, ih); // search image edge pixel position in case it is squashed vertically.\n\n  let sy = 0;\n  let ey = ih;\n  let py = ih;\n\n  while (py > sy) {\n    let alpha = data[(py - 1) * 4 + 3];\n\n    if (alpha === 0) {\n      ey = py;\n    } else {\n      sy = py;\n    }\n\n    py = ey + sy >> 1;\n  }\n\n  let ratio = py / ih;\n\n  if (ratio === 0) {\n    return 1;\n  } else {\n    return ratio;\n  }\n}; // A replacement for context.drawImage\n// (args are for source and destination).\n\n\nvar drawImageIOSFix = function (ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {\n  let vertSquashRatio = detectVerticalSquash(img);\n  return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);\n}; // Based on MinifyJpeg\n// Source: http://www.perry.cz/files/ExifRestorer.js\n// http://elicon.blog57.fc2.com/blog-entry-206.html\n\n\nclass ExifRestore {\n  static initClass() {\n    this.KEY_STR = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n  }\n\n  static encode64(input) {\n    let output = \"\";\n    let chr1 = undefined;\n    let chr2 = undefined;\n    let chr3 = \"\";\n    let enc1 = undefined;\n    let enc2 = undefined;\n    let enc3 = undefined;\n    let enc4 = \"\";\n    let i = 0;\n\n    while (true) {\n      chr1 = input[i++];\n      chr2 = input[i++];\n      chr3 = input[i++];\n      enc1 = chr1 >> 2;\n      enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n      enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n      enc4 = chr3 & 63;\n\n      if (isNaN(chr2)) {\n        enc3 = enc4 = 64;\n      } else if (isNaN(chr3)) {\n        enc4 = 64;\n      }\n\n      output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);\n      chr1 = chr2 = chr3 = \"\";\n      enc1 = enc2 = enc3 = enc4 = \"\";\n\n      if (!(i < input.length)) {\n        break;\n      }\n    }\n\n    return output;\n  }\n\n  static restore(origFileBase64, resizedFileBase64) {\n    if (!origFileBase64.match(\"data:image/jpeg;base64,\")) {\n      return resizedFileBase64;\n    }\n\n    let rawImage = this.decode64(origFileBase64.replace(\"data:image/jpeg;base64,\", \"\"));\n    let segments = this.slice2Segments(rawImage);\n    let image = this.exifManipulation(resizedFileBase64, segments);\n    return `data:image/jpeg;base64,${this.encode64(image)}`;\n  }\n\n  static exifManipulation(resizedFileBase64, segments) {\n    let exifArray = this.getExifArray(segments);\n    let newImageArray = this.insertExif(resizedFileBase64, exifArray);\n    let aBuffer = new Uint8Array(newImageArray);\n    return aBuffer;\n  }\n\n  static getExifArray(segments) {\n    let seg = undefined;\n    let x = 0;\n\n    while (x < segments.length) {\n      seg = segments[x];\n\n      if (seg[0] === 255 & seg[1] === 225) {\n        return seg;\n      }\n\n      x++;\n    }\n\n    return [];\n  }\n\n  static insertExif(resizedFileBase64, exifArray) {\n    let imageData = resizedFileBase64.replace(\"data:image/jpeg;base64,\", \"\");\n    let buf = this.decode64(imageData);\n    let separatePoint = buf.indexOf(255, 3);\n    let mae = buf.slice(0, separatePoint);\n    let ato = buf.slice(separatePoint);\n    let array = mae;\n    array = array.concat(exifArray);\n    array = array.concat(ato);\n    return array;\n  }\n\n  static slice2Segments(rawImageArray) {\n    let head = 0;\n    let segments = [];\n\n    while (true) {\n      var length;\n\n      if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) {\n        break;\n      }\n\n      if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) {\n        head += 2;\n      } else {\n        length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3];\n        let endPoint = head + length + 2;\n        let seg = rawImageArray.slice(head, endPoint);\n        segments.push(seg);\n        head = endPoint;\n      }\n\n      if (head > rawImageArray.length) {\n        break;\n      }\n    }\n\n    return segments;\n  }\n\n  static decode64(input) {\n    let output = \"\";\n    let chr1 = undefined;\n    let chr2 = undefined;\n    let chr3 = \"\";\n    let enc1 = undefined;\n    let enc2 = undefined;\n    let enc3 = undefined;\n    let enc4 = \"\";\n    let i = 0;\n    let buf = []; // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n\n    let base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n\n    if (base64test.exec(input)) {\n      console.warn(\"There were invalid base64 characters in the input text.\\nValid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\\nExpect errors in decoding.\");\n    }\n\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n    while (true) {\n      enc1 = this.KEY_STR.indexOf(input.charAt(i++));\n      enc2 = this.KEY_STR.indexOf(input.charAt(i++));\n      enc3 = this.KEY_STR.indexOf(input.charAt(i++));\n      enc4 = this.KEY_STR.indexOf(input.charAt(i++));\n      chr1 = enc1 << 2 | enc2 >> 4;\n      chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n      chr3 = (enc3 & 3) << 6 | enc4;\n      buf.push(chr1);\n\n      if (enc3 !== 64) {\n        buf.push(chr2);\n      }\n\n      if (enc4 !== 64) {\n        buf.push(chr3);\n      }\n\n      chr1 = chr2 = chr3 = \"\";\n      enc1 = enc2 = enc3 = enc4 = \"\";\n\n      if (!(i < input.length)) {\n        break;\n      }\n    }\n\n    return buf;\n  }\n\n}\n\nExifRestore.initClass();\n/*\n * contentloaded.js\n *\n * Author: Diego Perini (diego.perini at gmail.com)\n * Summary: cross-browser wrapper for DOMContentLoaded\n * Updated: 20101020\n * License: MIT\n * Version: 1.2\n *\n * URL:\n * http://javascript.nwbox.com/ContentLoaded/\n * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE\n */\n// @win window reference\n// @fn function reference\n\nlet contentLoaded = function (win, fn) {\n  let done = false;\n  let top = true;\n  let doc = win.document;\n  let root = doc.documentElement;\n  let add = doc.addEventListener ? \"addEventListener\" : \"attachEvent\";\n  let rem = doc.addEventListener ? \"removeEventListener\" : \"detachEvent\";\n  let pre = doc.addEventListener ? \"\" : \"on\";\n\n  var init = function (e) {\n    if (e.type === \"readystatechange\" && doc.readyState !== \"complete\") {\n      return;\n    }\n\n    (e.type === \"load\" ? win : doc)[rem](pre + e.type, init, false);\n\n    if (!done && (done = true)) {\n      return fn.call(win, e.type || e);\n    }\n  };\n\n  var poll = function () {\n    try {\n      root.doScroll(\"left\");\n    } catch (e) {\n      setTimeout(poll, 50);\n      return;\n    }\n\n    return init(\"poll\");\n  };\n\n  if (doc.readyState !== \"complete\") {\n    if (doc.createEventObject && root.doScroll) {\n      try {\n        top = !win.frameElement;\n      } catch (error) {}\n\n      if (top) {\n        poll();\n      }\n    }\n\n    doc[add](pre + \"DOMContentLoaded\", init, false);\n    doc[add](pre + \"readystatechange\", init, false);\n    return win[add](pre + \"load\", init, false);\n  }\n}; // As a single function to be able to write tests.\n\n\nDropzone._autoDiscoverFunction = function () {\n  if (Dropzone.autoDiscover) {\n    return Dropzone.discover();\n  }\n};\n\ncontentLoaded(window, Dropzone._autoDiscoverFunction);\n\nfunction __guard__(value, transform) {\n  return typeof value !== \"undefined\" && value !== null ? transform(value) : undefined;\n}\n\nfunction __guardMethod__(obj, methodName, transform) {\n  if (typeof obj !== \"undefined\" && obj !== null && typeof obj[methodName] === \"function\") {\n    return transform(obj, methodName);\n  } else {\n    return undefined;\n  }\n}\n\nexport { Dropzone };","map":{"version":3,"sources":["/home/if/test/node_modules/dropzone/src/dropzone.js"],"names":["Emitter","defaultOptions","Dropzone","initClass","prototype","events","_thumbnailQueue","_processingThumbnail","extend","target","objects","object","key","val","constructor","el","options","fallback","left","element","version","clickableElements","listeners","files","document","querySelector","nodeType","Error","dropzone","instances","push","elementOptions","optionsForElement","previewTemplate","replace","forceFallback","isBrowserSupported","call","url","getAttribute","acceptedFiles","acceptedMimeTypes","uploadMultiple","chunking","renameFilename","renameFile","file","name","method","toUpperCase","getExistingFallback","parentNode","removeChild","previewsContainer","getElement","clickable","getElements","init","getAcceptedFiles","filter","accepted","map","getRejectedFiles","getFilesWithStatus","status","getQueuedFiles","QUEUED","getUploadingFiles","UPLOADING","getAddedFiles","ADDED","getActiveFiles","tagName","setAttribute","classList","contains","appendChild","createElement","dictDefaultMessage","length","setupHiddenFileInput","hiddenFileInput","maxFiles","className","capture","style","visibility","position","top","height","width","hiddenInputContainer","addEventListener","addFile","emit","URL","window","webkitURL","eventName","on","updateTotalUploadProgress","setTimeout","containsFiles","e","dataTransfer","types","i","noPropagation","stopPropagation","preventDefault","returnValue","dragstart","dragenter","dragover","efct","effectAllowed","error","dropEffect","dragleave","drop","dragend","forEach","clickableElement","click","evt","elementInside","enable","destroy","disable","removeAllFiles","undefined","splice","indexOf","totalUploadProgress","totalBytesSent","totalBytes","activeFiles","upload","bytesSent","total","_getParamName","n","paramName","_renameFile","getFallbackForm","existingFallback","form","fieldsString","dictFallbackText","fields","getFallback","elements","test","getElementsByTagName","setupEventListeners","elementListeners","result","event","listener","removeEventListeners","removeEventListener","remove","disabled","cancelUpload","add","filesize","size","selectedSize","selectedUnit","units","unit","cutoff","Math","pow","filesizeBase","round","dictFileSizeUnits","_updateMaxFilesReachedClass","items","webkitGetAsEntry","_addFilesFromItems","handleFiles","paste","__guard__","clipboardData","x","item","entry","isFile","getAsFile","isDirectory","_addFilesFromDirectory","kind","directory","path","dirReader","createReader","errorHandler","__guardMethod__","console","o","log","readEntries","entries","ignoreHiddenFiles","substring","fullPath","accept","done","maxFilesize","dictFileTooBig","isValidFile","dictInvalidFileType","dictMaxFilesExceeded","uuid","uuidv4","progress","filename","_enqueueThumbnail","_errorProcessing","autoQueue","enqueueFile","enqueueFiles","autoProcessQueue","processQueue","createImageThumbnails","type","match","maxThumbnailFilesize","_processThumbnailQueue","shift","createThumbnail","thumbnailWidth","thumbnailHeight","thumbnailMethod","dataUrl","removeFile","without","cancelIfNecessary","slice","resizeImage","resizeMethod","callback","canvas","resizeMimeType","resizedDataURL","toDataURL","resizeQuality","ExifRestore","restore","dataURL","dataURItoBlob","fixOrientation","fileReader","FileReader","onload","createThumbnailFromUrl","readAsDataURL","displayExistingFile","mockFile","imageUrl","crossOrigin","resizeThumbnail","onDone","thumbnail","img","getComputedStyle","body","loadExif","EXIF","getData","getTag","orientation","resizeInfo","resize","ctx","getContext","trgWidth","trgHeight","translate","scale","rotate","PI","drawImageIOSFix","srcX","srcY","srcWidth","srcHeight","trgX","trgY","onerror","src","parallelUploads","processingLength","queuedFiles","processFiles","processFile","processing","uploadFiles","_getFilesWithXhr","xhr","groupedFiles","groupedFile","CANCELED","abort","resolveOption","option","args","apply","uploadFile","_transformFiles","transformedFiles","transformedFile","chunked","forceChunking","chunkSize","totalChunkCount","ceil","startedChunkCount","chunks","handleNextChunk","chunkIndex","start","end","min","dataBlock","data","webkitSlice","index","retries","_uploadData","finishedChunkUpload","chunk","response","allFinished","SUCCESS","chunksUploaded","_finished","parallelChunkUploads","dataBlocks","_getChunk","XMLHttpRequest","open","timeout","withCredentials","_finishedUploading","ontimeout","_handleUploadError","progressObj","onprogress","_updateFilesUploadProgress","headers","Accept","headerName","headerValue","setRequestHeader","formData","FormData","params","additionalParams","value","Array","isArray","append","_addFormElementData","submitRequest","doneCounter","transformFile","input","querySelectorAll","inputName","inputType","toLowerCase","hasAttribute","selected","checked","loaded","readyState","responseType","responseText","getResponseHeader","JSON","parse","retryChunks","retryChunksLimit","warn","dictResponseError","send","message","ERROR","c","r","random","v","toString","camelize","forElement","autoDiscover","discover","dropzones","checkElements","blockedBrowsers","capableBrowser","File","FileList","Blob","blacklistedBrowsers","regex","navigator","userAgent","dataURI","byteString","atob","split","mimeString","ab","ArrayBuffer","ia","Uint8Array","asc","charCodeAt","list","rejectedItem","str","charAt","string","div","innerHTML","childNodes","container","els","confirm","question","rejected","mimeType","baseMimeType","validType","trim","jQuery","fn","each","ACCEPTED","PROCESSING","detectVerticalSquash","iw","naturalWidth","ih","naturalHeight","drawImage","getImageData","sy","ey","py","alpha","ratio","sx","sw","sh","dx","dy","dw","dh","vertSquashRatio","KEY_STR","encode64","output","chr1","chr2","chr3","enc1","enc2","enc3","enc4","isNaN","origFileBase64","resizedFileBase64","rawImage","decode64","segments","slice2Segments","image","exifManipulation","exifArray","getExifArray","newImageArray","insertExif","aBuffer","seg","imageData","buf","separatePoint","mae","ato","array","concat","rawImageArray","head","endPoint","base64test","exec","contentLoaded","win","doc","root","documentElement","rem","pre","poll","doScroll","createEventObject","frameElement","_autoDiscoverFunction","transform","obj","methodName"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,cAApB;AACA,OAAOC,cAAP,MAA2B,cAA3B;AAEA,eAAe,MAAMC,QAAN,SAAuBF,OAAvB,CAA+B;AAC5B,SAATG,SAAS,GAAG;AACjB;AACA,SAAKC,SAAL,CAAeJ,OAAf,GAAyBA,OAAzB;AAEA;AACJ;AACA;AACA;AACA;;AAII,SAAKI,SAAL,CAAeC,MAAf,GAAwB,CACtB,MADsB,EAEtB,WAFsB,EAGtB,SAHsB,EAItB,WAJsB,EAKtB,UALsB,EAMtB,WANsB,EAOtB,WAPsB,EAQtB,YARsB,EAStB,aATsB,EAUtB,WAVsB,EAWtB,OAXsB,EAYtB,eAZsB,EAatB,YAbsB,EActB,oBAdsB,EAetB,gBAfsB,EAgBtB,qBAhBsB,EAiBtB,SAjBsB,EAkBtB,iBAlBsB,EAmBtB,SAnBsB,EAoBtB,iBApBsB,EAqBtB,UArBsB,EAsBtB,kBAtBsB,EAuBtB,UAvBsB,EAwBtB,kBAxBsB,EAyBtB,OAzBsB,EA0BtB,kBA1BsB,EA2BtB,iBA3BsB,EA4BtB,eA5BsB,CAAxB;AA+BA,SAAKD,SAAL,CAAeE,eAAf,GAAiC,EAAjC;AACA,SAAKF,SAAL,CAAeG,oBAAf,GAAsC,KAAtC;AACD,GA9C2C,CAgD5C;;;AACa,SAANC,MAAM,CAACC,MAAD,EAAS,GAAGC,OAAZ,EAAqB;AAChC,SAAK,IAAIC,MAAT,IAAmBD,OAAnB,EAA4B;AAC1B,WAAK,IAAIE,GAAT,IAAgBD,MAAhB,EAAwB;AACtB,YAAIE,GAAG,GAAGF,MAAM,CAACC,GAAD,CAAhB;AACAH,QAAAA,MAAM,CAACG,GAAD,CAAN,GAAcC,GAAd;AACD;AACF;;AACD,WAAOJ,MAAP;AACD;;AAEDK,EAAAA,WAAW,CAACC,EAAD,EAAKC,OAAL,EAAc;AACvB;AACA,QAAIC,QAAJ,EAAcC,IAAd;AACA,SAAKC,OAAL,GAAeJ,EAAf,CAHuB,CAIvB;;AACA,SAAKK,OAAL,GAAelB,QAAQ,CAACkB,OAAxB;AAEA,SAAKC,iBAAL,GAAyB,EAAzB;AACA,SAAKC,SAAL,GAAiB,EAAjB;AACA,SAAKC,KAAL,GAAa,EAAb,CATuB,CASN;;AAEjB,QAAI,OAAO,KAAKJ,OAAZ,KAAwB,QAA5B,EAAsC;AACpC,WAAKA,OAAL,GAAeK,QAAQ,CAACC,aAAT,CAAuB,KAAKN,OAA5B,CAAf;AACD,KAbsB,CAevB;;;AACA,QAAI,CAAC,KAAKA,OAAN,IAAiB,KAAKA,OAAL,CAAaO,QAAb,IAAyB,IAA9C,EAAoD;AAClD,YAAM,IAAIC,KAAJ,CAAU,2BAAV,CAAN;AACD;;AAED,QAAI,KAAKR,OAAL,CAAaS,QAAjB,EAA2B;AACzB,YAAM,IAAID,KAAJ,CAAU,4BAAV,CAAN;AACD,KAtBsB,CAwBvB;;;AACAzB,IAAAA,QAAQ,CAAC2B,SAAT,CAAmBC,IAAnB,CAAwB,IAAxB,EAzBuB,CA2BvB;;AACA,SAAKX,OAAL,CAAaS,QAAb,GAAwB,IAAxB;AAEA,QAAIG,cAAc,GAChB,CAACb,IAAI,GAAGhB,QAAQ,CAAC8B,iBAAT,CAA2B,KAAKb,OAAhC,CAAR,KAAqD,IAArD,GAA4DD,IAA5D,GAAmE,EADrE;AAGA,SAAKF,OAAL,GAAed,QAAQ,CAACM,MAAT,CACb,EADa,EAEbP,cAFa,EAGb8B,cAHa,EAIbf,OAAO,IAAI,IAAX,GAAkBA,OAAlB,GAA4B,EAJf,CAAf;AAOA,SAAKA,OAAL,CAAaiB,eAAb,GAA+B,KAAKjB,OAAL,CAAaiB,eAAb,CAA6BC,OAA7B,CAC7B,MAD6B,EAE7B,EAF6B,CAA/B,CAxCuB,CA6CvB;;AACA,QAAI,KAAKlB,OAAL,CAAamB,aAAb,IAA8B,CAACjC,QAAQ,CAACkC,kBAAT,EAAnC,EAAkE;AAChE,aAAO,KAAKpB,OAAL,CAAaC,QAAb,CAAsBoB,IAAtB,CAA2B,IAA3B,CAAP;AACD,KAhDsB,CAkDvB;;;AACA,QAAI,KAAKrB,OAAL,CAAasB,GAAb,IAAoB,IAAxB,EAA8B;AAC5B,WAAKtB,OAAL,CAAasB,GAAb,GAAmB,KAAKnB,OAAL,CAAaoB,YAAb,CAA0B,QAA1B,CAAnB;AACD;;AAED,QAAI,CAAC,KAAKvB,OAAL,CAAasB,GAAlB,EAAuB;AACrB,YAAM,IAAIX,KAAJ,CAAU,kBAAV,CAAN;AACD;;AAED,QAAI,KAAKX,OAAL,CAAawB,aAAb,IAA8B,KAAKxB,OAAL,CAAayB,iBAA/C,EAAkE;AAChE,YAAM,IAAId,KAAJ,CACJ,oGADI,CAAN;AAGD;;AAED,QAAI,KAAKX,OAAL,CAAa0B,cAAb,IAA+B,KAAK1B,OAAL,CAAa2B,QAAhD,EAA0D;AACxD,YAAM,IAAIhB,KAAJ,CAAU,mDAAV,CAAN;AACD,KAnEsB,CAqEvB;;;AACA,QAAI,KAAKX,OAAL,CAAayB,iBAAjB,EAAoC;AAClC,WAAKzB,OAAL,CAAawB,aAAb,GAA6B,KAAKxB,OAAL,CAAayB,iBAA1C;AACA,aAAO,KAAKzB,OAAL,CAAayB,iBAApB;AACD,KAzEsB,CA2EvB;;;AACA,QAAI,KAAKzB,OAAL,CAAa4B,cAAb,IAA+B,IAAnC,EAAyC;AACvC,WAAK5B,OAAL,CAAa6B,UAAb,GAA2BC,IAAD,IACxB,KAAK9B,OAAL,CAAa4B,cAAb,CAA4BP,IAA5B,CAAiC,IAAjC,EAAuCS,IAAI,CAACC,IAA5C,EAAkDD,IAAlD,CADF;AAED;;AAED,QAAI,OAAO,KAAK9B,OAAL,CAAagC,MAApB,KAA+B,QAAnC,EAA6C;AAC3C,WAAKhC,OAAL,CAAagC,MAAb,GAAsB,KAAKhC,OAAL,CAAagC,MAAb,CAAoBC,WAApB,EAAtB;AACD;;AAED,QAAI,CAAChC,QAAQ,GAAG,KAAKiC,mBAAL,EAAZ,KAA2CjC,QAAQ,CAACkC,UAAxD,EAAoE;AAClE;AACAlC,MAAAA,QAAQ,CAACkC,UAAT,CAAoBC,WAApB,CAAgCnC,QAAhC;AACD,KAxFsB,CA0FvB;;;AACA,QAAI,KAAKD,OAAL,CAAaqC,iBAAb,KAAmC,KAAvC,EAA8C;AAC5C,UAAI,KAAKrC,OAAL,CAAaqC,iBAAjB,EAAoC;AAClC,aAAKA,iBAAL,GAAyBnD,QAAQ,CAACoD,UAAT,CACvB,KAAKtC,OAAL,CAAaqC,iBADU,EAEvB,mBAFuB,CAAzB;AAID,OALD,MAKO;AACL,aAAKA,iBAAL,GAAyB,KAAKlC,OAA9B;AACD;AACF;;AAED,QAAI,KAAKH,OAAL,CAAauC,SAAjB,EAA4B;AAC1B,UAAI,KAAKvC,OAAL,CAAauC,SAAb,KAA2B,IAA/B,EAAqC;AACnC,aAAKlC,iBAAL,GAAyB,CAAC,KAAKF,OAAN,CAAzB;AACD,OAFD,MAEO;AACL,aAAKE,iBAAL,GAAyBnB,QAAQ,CAACsD,WAAT,CACvB,KAAKxC,OAAL,CAAauC,SADU,EAEvB,WAFuB,CAAzB;AAID;AACF;;AAED,SAAKE,IAAL;AACD,GA7K2C,CA+K5C;;;AACAC,EAAAA,gBAAgB,GAAG;AACjB,WAAO,KAAKnC,KAAL,CAAWoC,MAAX,CAAmBb,IAAD,IAAUA,IAAI,CAACc,QAAjC,EAA2CC,GAA3C,CAAgDf,IAAD,IAAUA,IAAzD,CAAP;AACD,GAlL2C,CAoL5C;AACA;;;AACAgB,EAAAA,gBAAgB,GAAG;AACjB,WAAO,KAAKvC,KAAL,CAAWoC,MAAX,CAAmBb,IAAD,IAAU,CAACA,IAAI,CAACc,QAAlC,EAA4CC,GAA5C,CAAiDf,IAAD,IAAUA,IAA1D,CAAP;AACD;;AAEDiB,EAAAA,kBAAkB,CAACC,MAAD,EAAS;AACzB,WAAO,KAAKzC,KAAL,CACJoC,MADI,CACIb,IAAD,IAAUA,IAAI,CAACkB,MAAL,KAAgBA,MAD7B,EAEJH,GAFI,CAECf,IAAD,IAAUA,IAFV,CAAP;AAGD,GA9L2C,CAgM5C;;;AACAmB,EAAAA,cAAc,GAAG;AACf,WAAO,KAAKF,kBAAL,CAAwB7D,QAAQ,CAACgE,MAAjC,CAAP;AACD;;AAEDC,EAAAA,iBAAiB,GAAG;AAClB,WAAO,KAAKJ,kBAAL,CAAwB7D,QAAQ,CAACkE,SAAjC,CAAP;AACD;;AAEDC,EAAAA,aAAa,GAAG;AACd,WAAO,KAAKN,kBAAL,CAAwB7D,QAAQ,CAACoE,KAAjC,CAAP;AACD,GA3M2C,CA6M5C;;;AACAC,EAAAA,cAAc,GAAG;AACf,WAAO,KAAKhD,KAAL,CACJoC,MADI,CAEFb,IAAD,IACEA,IAAI,CAACkB,MAAL,KAAgB9D,QAAQ,CAACkE,SAAzB,IAAsCtB,IAAI,CAACkB,MAAL,KAAgB9D,QAAQ,CAACgE,MAH9D,EAKJL,GALI,CAKCf,IAAD,IAAUA,IALV,CAAP;AAMD,GArN2C,CAuN5C;AACA;;;AACAW,EAAAA,IAAI,GAAG;AACL;AACA,QAAI,KAAKtC,OAAL,CAAaqD,OAAb,KAAyB,MAA7B,EAAqC;AACnC,WAAKrD,OAAL,CAAasD,YAAb,CAA0B,SAA1B,EAAqC,qBAArC;AACD;;AAED,QACE,KAAKtD,OAAL,CAAauD,SAAb,CAAuBC,QAAvB,CAAgC,UAAhC,KACA,CAAC,KAAKxD,OAAL,CAAaM,aAAb,CAA2B,aAA3B,CAFH,EAGE;AACA,WAAKN,OAAL,CAAayD,WAAb,CACE1E,QAAQ,CAAC2E,aAAT,CACG,8EAA6E,KAAK7D,OAAL,CAAa8D,kBAAmB,iBADhH,CADF;AAKD;;AAED,QAAI,KAAKzD,iBAAL,CAAuB0D,MAA3B,EAAmC;AACjC,UAAIC,oBAAoB,GAAG,MAAM;AAC/B,YAAI,KAAKC,eAAT,EAA0B;AACxB,eAAKA,eAAL,CAAqB9B,UAArB,CAAgCC,WAAhC,CAA4C,KAAK6B,eAAjD;AACD;;AACD,aAAKA,eAAL,GAAuBzD,QAAQ,CAACqD,aAAT,CAAuB,OAAvB,CAAvB;AACA,aAAKI,eAAL,CAAqBR,YAArB,CAAkC,MAAlC,EAA0C,MAA1C;;AACA,YAAI,KAAKzD,OAAL,CAAakE,QAAb,KAA0B,IAA1B,IAAkC,KAAKlE,OAAL,CAAakE,QAAb,GAAwB,CAA9D,EAAiE;AAC/D,eAAKD,eAAL,CAAqBR,YAArB,CAAkC,UAAlC,EAA8C,UAA9C;AACD;;AACD,aAAKQ,eAAL,CAAqBE,SAArB,GAAiC,iBAAjC;;AAEA,YAAI,KAAKnE,OAAL,CAAawB,aAAb,KAA+B,IAAnC,EAAyC;AACvC,eAAKyC,eAAL,CAAqBR,YAArB,CACE,QADF,EAEE,KAAKzD,OAAL,CAAawB,aAFf;AAID;;AACD,YAAI,KAAKxB,OAAL,CAAaoE,OAAb,KAAyB,IAA7B,EAAmC;AACjC,eAAKH,eAAL,CAAqBR,YAArB,CAAkC,SAAlC,EAA6C,KAAKzD,OAAL,CAAaoE,OAA1D;AACD,SAnB8B,CAqB/B;;;AACA,aAAKH,eAAL,CAAqBR,YAArB,CAAkC,UAAlC,EAA8C,IAA9C,EAtB+B,CAwB/B;AACA;;AACA,aAAKQ,eAAL,CAAqBI,KAArB,CAA2BC,UAA3B,GAAwC,QAAxC;AACA,aAAKL,eAAL,CAAqBI,KAArB,CAA2BE,QAA3B,GAAsC,UAAtC;AACA,aAAKN,eAAL,CAAqBI,KAArB,CAA2BG,GAA3B,GAAiC,GAAjC;AACA,aAAKP,eAAL,CAAqBI,KAArB,CAA2BnE,IAA3B,GAAkC,GAAlC;AACA,aAAK+D,eAAL,CAAqBI,KAArB,CAA2BI,MAA3B,GAAoC,GAApC;AACA,aAAKR,eAAL,CAAqBI,KAArB,CAA2BK,KAA3B,GAAmC,GAAnC;AACAxF,QAAAA,QAAQ,CAACoD,UAAT,CACE,KAAKtC,OAAL,CAAa2E,oBADf,EAEE,sBAFF,EAGEf,WAHF,CAGc,KAAKK,eAHnB;AAIA,aAAKA,eAAL,CAAqBW,gBAArB,CAAsC,QAAtC,EAAgD,MAAM;AACpD,cAAI;AAAErE,YAAAA;AAAF,cAAY,KAAK0D,eAArB;;AACA,cAAI1D,KAAK,CAACwD,MAAV,EAAkB;AAChB,iBAAK,IAAIjC,IAAT,IAAiBvB,KAAjB,EAAwB;AACtB,mBAAKsE,OAAL,CAAa/C,IAAb;AACD;AACF;;AACD,eAAKgD,IAAL,CAAU,YAAV,EAAwBvE,KAAxB;AACAyD,UAAAA,oBAAoB;AACrB,SATD;AAUD,OA9CD;;AA+CAA,MAAAA,oBAAoB;AACrB;;AAED,SAAKe,GAAL,GAAWC,MAAM,CAACD,GAAP,KAAe,IAAf,GAAsBC,MAAM,CAACD,GAA7B,GAAmCC,MAAM,CAACC,SAArD,CApEK,CAsEL;AACA;AACA;;AACA,SAAK,IAAIC,SAAT,IAAsB,KAAK7F,MAA3B,EAAmC;AACjC,WAAK8F,EAAL,CAAQD,SAAR,EAAmB,KAAKlF,OAAL,CAAakF,SAAb,CAAnB;AACD;;AAED,SAAKC,EAAL,CAAQ,gBAAR,EAA0B,MAAM,KAAKC,yBAAL,EAAhC;AAEA,SAAKD,EAAL,CAAQ,aAAR,EAAuB,MAAM,KAAKC,yBAAL,EAA7B;AAEA,SAAKD,EAAL,CAAQ,UAAR,EAAqBrD,IAAD,IAAU,KAAKgD,IAAL,CAAU,UAAV,EAAsBhD,IAAtB,CAA9B,EAjFK,CAmFL;;AACA,SAAKqD,EAAL,CAAQ,UAAR,EAAqBrD,IAAD,IAAU;AAC5B,UACE,KAAKuB,aAAL,GAAqBU,MAArB,KAAgC,CAAhC,IACA,KAAKZ,iBAAL,GAAyBY,MAAzB,KAAoC,CADpC,IAEA,KAAKd,cAAL,GAAsBc,MAAtB,KAAiC,CAHnC,EAIE;AACA;AACA,eAAOsB,UAAU,CAAC,MAAM,KAAKP,IAAL,CAAU,eAAV,CAAP,EAAmC,CAAnC,CAAjB;AACD;AACF,KATD;;AAWA,UAAMQ,aAAa,GAAG,UAAUC,CAAV,EAAa;AACjC,UAAIA,CAAC,CAACC,YAAF,CAAeC,KAAnB,EAA0B;AACxB;AACA;AACA;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,CAAC,CAACC,YAAF,CAAeC,KAAf,CAAqB1B,MAAzC,EAAiD2B,CAAC,EAAlD,EAAsD;AACpD,cAAIH,CAAC,CAACC,YAAF,CAAeC,KAAf,CAAqBC,CAArB,MAA4B,OAAhC,EAAyC,OAAO,IAAP;AAC1C;AACF;;AACD,aAAO,KAAP;AACD,KAVD;;AAYA,QAAIC,aAAa,GAAG,UAAUJ,CAAV,EAAa;AAC/B;AACA;AACA;AACA,UAAI,CAACD,aAAa,CAACC,CAAD,CAAlB,EAAuB;AACvBA,MAAAA,CAAC,CAACK,eAAF;;AACA,UAAIL,CAAC,CAACM,cAAN,EAAsB;AACpB,eAAON,CAAC,CAACM,cAAF,EAAP;AACD,OAFD,MAEO;AACL,eAAQN,CAAC,CAACO,WAAF,GAAgB,KAAxB;AACD;AACF,KAXD,CA3GK,CAwHL;;;AACA,SAAKxF,SAAL,GAAiB,CACf;AACEH,MAAAA,OAAO,EAAE,KAAKA,OADhB;AAEEd,MAAAA,MAAM,EAAE;AACN0G,QAAAA,SAAS,EAAGR,CAAD,IAAO;AAChB,iBAAO,KAAKT,IAAL,CAAU,WAAV,EAAuBS,CAAvB,CAAP;AACD,SAHK;AAINS,QAAAA,SAAS,EAAGT,CAAD,IAAO;AAChBI,UAAAA,aAAa,CAACJ,CAAD,CAAb;AACA,iBAAO,KAAKT,IAAL,CAAU,WAAV,EAAuBS,CAAvB,CAAP;AACD,SAPK;AAQNU,QAAAA,QAAQ,EAAGV,CAAD,IAAO;AACf;AACA;AACA;AACA,cAAIW,IAAJ;;AACA,cAAI;AACFA,YAAAA,IAAI,GAAGX,CAAC,CAACC,YAAF,CAAeW,aAAtB;AACD,WAFD,CAEE,OAAOC,KAAP,EAAc,CAAE;;AAClBb,UAAAA,CAAC,CAACC,YAAF,CAAea,UAAf,GACE,WAAWH,IAAX,IAAmB,eAAeA,IAAlC,GAAyC,MAAzC,GAAkD,MADpD;AAGAP,UAAAA,aAAa,CAACJ,CAAD,CAAb;AACA,iBAAO,KAAKT,IAAL,CAAU,UAAV,EAAsBS,CAAtB,CAAP;AACD,SArBK;AAsBNe,QAAAA,SAAS,EAAGf,CAAD,IAAO;AAChB,iBAAO,KAAKT,IAAL,CAAU,WAAV,EAAuBS,CAAvB,CAAP;AACD,SAxBK;AAyBNgB,QAAAA,IAAI,EAAGhB,CAAD,IAAO;AACXI,UAAAA,aAAa,CAACJ,CAAD,CAAb;AACA,iBAAO,KAAKgB,IAAL,CAAUhB,CAAV,CAAP;AACD,SA5BK;AA6BNiB,QAAAA,OAAO,EAAGjB,CAAD,IAAO;AACd,iBAAO,KAAKT,IAAL,CAAU,SAAV,EAAqBS,CAArB,CAAP;AACD;AA/BK,OAFV,CAoCE;AACA;AACA;AACA;;AAvCF,KADe,CAAjB;AA4CA,SAAKlF,iBAAL,CAAuBoG,OAAvB,CAAgCC,gBAAD,IAAsB;AACnD,aAAO,KAAKpG,SAAL,CAAeQ,IAAf,CAAoB;AACzBX,QAAAA,OAAO,EAAEuG,gBADgB;AAEzBrH,QAAAA,MAAM,EAAE;AACNsH,UAAAA,KAAK,EAAGC,GAAD,IAAS;AACd;AACA,gBACEF,gBAAgB,KAAK,KAAKvG,OAA1B,IACAyG,GAAG,CAACnH,MAAJ,KAAe,KAAKU,OADpB,IAEAjB,QAAQ,CAAC2H,aAAT,CACED,GAAG,CAACnH,MADN,EAEE,KAAKU,OAAL,CAAaM,aAAb,CAA2B,aAA3B,CAFF,CAHF,EAOE;AACA,mBAAKwD,eAAL,CAAqB0C,KAArB,GADA,CAC8B;AAC/B;;AACD,mBAAO,IAAP;AACD;AAdK;AAFiB,OAApB,CAAP;AAmBD,KApBD;AAsBA,SAAKG,MAAL;AAEA,WAAO,KAAK9G,OAAL,CAAayC,IAAb,CAAkBpB,IAAlB,CAAuB,IAAvB,CAAP;AACD,GAvZ2C,CAyZ5C;;;AACA0F,EAAAA,OAAO,GAAG;AACR,SAAKC,OAAL;AACA,SAAKC,cAAL,CAAoB,IAApB;;AACA,QACE,KAAKhD,eAAL,IAAwB,IAAxB,GAA+B,KAAKA,eAAL,CAAqB9B,UAApD,GAAiE+E,SADnE,EAEE;AACA,WAAKjD,eAAL,CAAqB9B,UAArB,CAAgCC,WAAhC,CAA4C,KAAK6B,eAAjD;AACA,WAAKA,eAAL,GAAuB,IAAvB;AACD;;AACD,WAAO,KAAK9D,OAAL,CAAaS,QAApB;AACA,WAAO1B,QAAQ,CAAC2B,SAAT,CAAmBsG,MAAnB,CAA0BjI,QAAQ,CAAC2B,SAAT,CAAmBuG,OAAnB,CAA2B,IAA3B,CAA1B,EAA4D,CAA5D,CAAP;AACD;;AAEDhC,EAAAA,yBAAyB,GAAG;AAC1B,QAAIiC,mBAAJ;AACA,QAAIC,cAAc,GAAG,CAArB;AACA,QAAIC,UAAU,GAAG,CAAjB;AAEA,QAAIC,WAAW,GAAG,KAAKjE,cAAL,EAAlB;;AAEA,QAAIiE,WAAW,CAACzD,MAAhB,EAAwB;AACtB,WAAK,IAAIjC,IAAT,IAAiB,KAAKyB,cAAL,EAAjB,EAAwC;AACtC+D,QAAAA,cAAc,IAAIxF,IAAI,CAAC2F,MAAL,CAAYC,SAA9B;AACAH,QAAAA,UAAU,IAAIzF,IAAI,CAAC2F,MAAL,CAAYE,KAA1B;AACD;;AACDN,MAAAA,mBAAmB,GAAI,MAAMC,cAAP,GAAyBC,UAA/C;AACD,KAND,MAMO;AACLF,MAAAA,mBAAmB,GAAG,GAAtB;AACD;;AAED,WAAO,KAAKvC,IAAL,CACL,qBADK,EAELuC,mBAFK,EAGLE,UAHK,EAILD,cAJK,CAAP;AAMD,GA9b2C,CAgc5C;AACA;;;AACAM,EAAAA,aAAa,CAACC,CAAD,EAAI;AACf,QAAI,OAAO,KAAK7H,OAAL,CAAa8H,SAApB,KAAkC,UAAtC,EAAkD;AAChD,aAAO,KAAK9H,OAAL,CAAa8H,SAAb,CAAuBD,CAAvB,CAAP;AACD,KAFD,MAEO;AACL,aAAQ,GAAE,KAAK7H,OAAL,CAAa8H,SAAU,GAC/B,KAAK9H,OAAL,CAAa0B,cAAb,GAA+B,IAAGmG,CAAE,GAApC,GAAyC,EAC1C,EAFD;AAGD;AACF,GA1c2C,CA4c5C;AACA;;;AACAE,EAAAA,WAAW,CAACjG,IAAD,EAAO;AAChB,QAAI,OAAO,KAAK9B,OAAL,CAAa6B,UAApB,KAAmC,UAAvC,EAAmD;AACjD,aAAOC,IAAI,CAACC,IAAZ;AACD;;AACD,WAAO,KAAK/B,OAAL,CAAa6B,UAAb,CAAwBC,IAAxB,CAAP;AACD,GAnd2C,CAqd5C;AACA;AACA;AACA;;;AACAkG,EAAAA,eAAe,GAAG;AAChB,QAAIC,gBAAJ,EAAsBC,IAAtB;;AACA,QAAKD,gBAAgB,GAAG,KAAK/F,mBAAL,EAAxB,EAAqD;AACnD,aAAO+F,gBAAP;AACD;;AAED,QAAIE,YAAY,GAAG,2BAAnB;;AACA,QAAI,KAAKnI,OAAL,CAAaoI,gBAAjB,EAAmC;AACjCD,MAAAA,YAAY,IAAK,MAAK,KAAKnI,OAAL,CAAaoI,gBAAiB,MAApD;AACD;;AACDD,IAAAA,YAAY,IAAK,4BAA2B,KAAKP,aAAL,CAAmB,CAAnB,CAAsB,KAChE,KAAK5H,OAAL,CAAa0B,cAAb,GAA8B,qBAA9B,GAAsDwF,SACvD,gDAFD;AAIA,QAAImB,MAAM,GAAGnJ,QAAQ,CAAC2E,aAAT,CAAuBsE,YAAvB,CAAb;;AACA,QAAI,KAAKhI,OAAL,CAAaqD,OAAb,KAAyB,MAA7B,EAAqC;AACnC0E,MAAAA,IAAI,GAAGhJ,QAAQ,CAAC2E,aAAT,CACJ,iBAAgB,KAAK7D,OAAL,CAAasB,GAAI,2CAA0C,KAAKtB,OAAL,CAAagC,MAAO,WAD3F,CAAP;AAGAkG,MAAAA,IAAI,CAACtE,WAAL,CAAiByE,MAAjB;AACD,KALD,MAKO;AACL;AACA,WAAKlI,OAAL,CAAasD,YAAb,CAA0B,SAA1B,EAAqC,qBAArC;AACA,WAAKtD,OAAL,CAAasD,YAAb,CAA0B,QAA1B,EAAoC,KAAKzD,OAAL,CAAagC,MAAjD;AACD;;AACD,WAAOkG,IAAI,IAAI,IAAR,GAAeA,IAAf,GAAsBG,MAA7B;AACD,GAnf2C,CAqf5C;AACA;AACA;;;AACAnG,EAAAA,mBAAmB,GAAG;AACpB,QAAIoG,WAAW,GAAG,UAAUC,QAAV,EAAoB;AACpC,WAAK,IAAIxI,EAAT,IAAewI,QAAf,EAAyB;AACvB,YAAI,qBAAqBC,IAArB,CAA0BzI,EAAE,CAACoE,SAA7B,CAAJ,EAA6C;AAC3C,iBAAOpE,EAAP;AACD;AACF;AACF,KAND;;AAQA,SAAK,IAAIyD,OAAT,IAAoB,CAAC,KAAD,EAAQ,MAAR,CAApB,EAAqC;AACnC,UAAIvD,QAAJ;;AACA,UACGA,QAAQ,GAAGqI,WAAW,CAAC,KAAKnI,OAAL,CAAasI,oBAAb,CAAkCjF,OAAlC,CAAD,CADzB,EAEE;AACA,eAAOvD,QAAP;AACD;AACF;AACF,GAzgB2C,CA2gB5C;;;AACAyI,EAAAA,mBAAmB,GAAG;AACpB,WAAO,KAAKpI,SAAL,CAAeuC,GAAf,CAAoB8F,gBAAD,IACxB,CAAC,MAAM;AACL,UAAIC,MAAM,GAAG,EAAb;;AACA,WAAK,IAAIC,KAAT,IAAkBF,gBAAgB,CAACtJ,MAAnC,EAA2C;AACzC,YAAIyJ,QAAQ,GAAGH,gBAAgB,CAACtJ,MAAjB,CAAwBwJ,KAAxB,CAAf;AACAD,QAAAA,MAAM,CAAC9H,IAAP,CACE6H,gBAAgB,CAACxI,OAAjB,CAAyByE,gBAAzB,CAA0CiE,KAA1C,EAAiDC,QAAjD,EAA2D,KAA3D,CADF;AAGD;;AACD,aAAOF,MAAP;AACD,KATD,GADK,CAAP;AAYD,GAzhB2C,CA2hB5C;;;AACAG,EAAAA,oBAAoB,GAAG;AACrB,WAAO,KAAKzI,SAAL,CAAeuC,GAAf,CAAoB8F,gBAAD,IACxB,CAAC,MAAM;AACL,UAAIC,MAAM,GAAG,EAAb;;AACA,WAAK,IAAIC,KAAT,IAAkBF,gBAAgB,CAACtJ,MAAnC,EAA2C;AACzC,YAAIyJ,QAAQ,GAAGH,gBAAgB,CAACtJ,MAAjB,CAAwBwJ,KAAxB,CAAf;AACAD,QAAAA,MAAM,CAAC9H,IAAP,CACE6H,gBAAgB,CAACxI,OAAjB,CAAyB6I,mBAAzB,CAA6CH,KAA7C,EAAoDC,QAApD,EAA8D,KAA9D,CADF;AAGD;;AACD,aAAOF,MAAP;AACD,KATD,GADK,CAAP;AAYD,GAziB2C,CA2iB5C;;;AACA5B,EAAAA,OAAO,GAAG;AACR,SAAK3G,iBAAL,CAAuBoG,OAAvB,CAAgCtG,OAAD,IAC7BA,OAAO,CAACuD,SAAR,CAAkBuF,MAAlB,CAAyB,cAAzB,CADF;AAGA,SAAKF,oBAAL;AACA,SAAKG,QAAL,GAAgB,IAAhB;AAEA,WAAO,KAAK3I,KAAL,CAAWsC,GAAX,CAAgBf,IAAD,IAAU,KAAKqH,YAAL,CAAkBrH,IAAlB,CAAzB,CAAP;AACD;;AAEDgF,EAAAA,MAAM,GAAG;AACP,WAAO,KAAKoC,QAAZ;AACA,SAAK7I,iBAAL,CAAuBoG,OAAvB,CAAgCtG,OAAD,IAC7BA,OAAO,CAACuD,SAAR,CAAkB0F,GAAlB,CAAsB,cAAtB,CADF;AAGA,WAAO,KAAKV,mBAAL,EAAP;AACD,GA5jB2C,CA8jB5C;;;AACAW,EAAAA,QAAQ,CAACC,IAAD,EAAO;AACb,QAAIC,YAAY,GAAG,CAAnB;AACA,QAAIC,YAAY,GAAG,GAAnB;;AAEA,QAAIF,IAAI,GAAG,CAAX,EAAc;AACZ,UAAIG,KAAK,GAAG,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,GAAzB,CAAZ;;AAEA,WAAK,IAAI/D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+D,KAAK,CAAC1F,MAA1B,EAAkC2B,CAAC,EAAnC,EAAuC;AACrC,YAAIgE,IAAI,GAAGD,KAAK,CAAC/D,CAAD,CAAhB;AACA,YAAIiE,MAAM,GAAGC,IAAI,CAACC,GAAL,CAAS,KAAK7J,OAAL,CAAa8J,YAAtB,EAAoC,IAAIpE,CAAxC,IAA6C,EAA1D;;AAEA,YAAI4D,IAAI,IAAIK,MAAZ,EAAoB;AAClBJ,UAAAA,YAAY,GAAGD,IAAI,GAAGM,IAAI,CAACC,GAAL,CAAS,KAAK7J,OAAL,CAAa8J,YAAtB,EAAoC,IAAIpE,CAAxC,CAAtB;AACA8D,UAAAA,YAAY,GAAGE,IAAf;AACA;AACD;AACF;;AAEDH,MAAAA,YAAY,GAAGK,IAAI,CAACG,KAAL,CAAW,KAAKR,YAAhB,IAAgC,EAA/C,CAdY,CAcuC;AACpD;;AAED,WAAQ,WAAUA,YAAa,aAAY,KAAKvJ,OAAL,CAAagK,iBAAb,CAA+BR,YAA/B,CAA6C,EAAxF;AACD,GArlB2C,CAulB5C;;;AACAS,EAAAA,2BAA2B,GAAG;AAC5B,QACE,KAAKjK,OAAL,CAAakE,QAAb,IAAyB,IAAzB,IACA,KAAKxB,gBAAL,GAAwBqB,MAAxB,IAAkC,KAAK/D,OAAL,CAAakE,QAFjD,EAGE;AACA,UAAI,KAAKxB,gBAAL,GAAwBqB,MAAxB,KAAmC,KAAK/D,OAAL,CAAakE,QAApD,EAA8D;AAC5D,aAAKY,IAAL,CAAU,iBAAV,EAA6B,KAAKvE,KAAlC;AACD;;AACD,aAAO,KAAKJ,OAAL,CAAauD,SAAb,CAAuB0F,GAAvB,CAA2B,sBAA3B,CAAP;AACD,KARD,MAQO;AACL,aAAO,KAAKjJ,OAAL,CAAauD,SAAb,CAAuBuF,MAAvB,CAA8B,sBAA9B,CAAP;AACD;AACF;;AAED1C,EAAAA,IAAI,CAAChB,CAAD,EAAI;AACN,QAAI,CAACA,CAAC,CAACC,YAAP,EAAqB;AACnB;AACD;;AACD,SAAKV,IAAL,CAAU,MAAV,EAAkBS,CAAlB,EAJM,CAMN;AACA;;AACA,QAAIhF,KAAK,GAAG,EAAZ;;AACA,SAAK,IAAImF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,CAAC,CAACC,YAAF,CAAejF,KAAf,CAAqBwD,MAAzC,EAAiD2B,CAAC,EAAlD,EAAsD;AACpDnF,MAAAA,KAAK,CAACmF,CAAD,CAAL,GAAWH,CAAC,CAACC,YAAF,CAAejF,KAAf,CAAqBmF,CAArB,CAAX;AACD,KAXK,CAaN;;;AACA,QAAInF,KAAK,CAACwD,MAAV,EAAkB;AAChB,UAAI;AAAEmG,QAAAA;AAAF,UAAY3E,CAAC,CAACC,YAAlB;;AACA,UAAI0E,KAAK,IAAIA,KAAK,CAACnG,MAAf,IAAyBmG,KAAK,CAAC,CAAD,CAAL,CAASC,gBAAT,IAA6B,IAA1D,EAAgE;AAC9D;AACA,aAAKC,kBAAL,CAAwBF,KAAxB;AACD,OAHD,MAGO;AACL,aAAKG,WAAL,CAAiB9J,KAAjB;AACD;AACF;;AAED,SAAKuE,IAAL,CAAU,YAAV,EAAwBvE,KAAxB;AACD;;AAED+J,EAAAA,KAAK,CAAC/E,CAAD,EAAI;AACP,QACEgF,SAAS,CAAChF,CAAC,IAAI,IAAL,GAAYA,CAAC,CAACiF,aAAd,GAA8BtD,SAA/B,EAA2CuD,CAAD,IAAOA,CAAC,CAACP,KAAnD,CAAT,IAAsE,IADxE,EAEE;AACA;AACD;;AAED,SAAKpF,IAAL,CAAU,OAAV,EAAmBS,CAAnB;AACA,QAAI;AAAE2E,MAAAA;AAAF,QAAY3E,CAAC,CAACiF,aAAlB;;AAEA,QAAIN,KAAK,CAACnG,MAAV,EAAkB;AAChB,aAAO,KAAKqG,kBAAL,CAAwBF,KAAxB,CAAP;AACD;AACF;;AAEDG,EAAAA,WAAW,CAAC9J,KAAD,EAAQ;AACjB,SAAK,IAAIuB,IAAT,IAAiBvB,KAAjB,EAAwB;AACtB,WAAKsE,OAAL,CAAa/C,IAAb;AACD;AACF,GAppB2C,CAspB5C;AACA;;;AACAsI,EAAAA,kBAAkB,CAACF,KAAD,EAAQ;AACxB,WAAO,CAAC,MAAM;AACZ,UAAItB,MAAM,GAAG,EAAb;;AACA,WAAK,IAAI8B,IAAT,IAAiBR,KAAjB,EAAwB;AACtB,YAAIS,KAAJ;;AACA,YACED,IAAI,CAACP,gBAAL,IAAyB,IAAzB,KACCQ,KAAK,GAAGD,IAAI,CAACP,gBAAL,EADT,CADF,EAGE;AACA,cAAIQ,KAAK,CAACC,MAAV,EAAkB;AAChBhC,YAAAA,MAAM,CAAC9H,IAAP,CAAY,KAAK+D,OAAL,CAAa6F,IAAI,CAACG,SAAL,EAAb,CAAZ;AACD,WAFD,MAEO,IAAIF,KAAK,CAACG,WAAV,EAAuB;AAC5B;AACAlC,YAAAA,MAAM,CAAC9H,IAAP,CAAY,KAAKiK,sBAAL,CAA4BJ,KAA5B,EAAmCA,KAAK,CAAC5I,IAAzC,CAAZ;AACD,WAHM,MAGA;AACL6G,YAAAA,MAAM,CAAC9H,IAAP,CAAYoG,SAAZ;AACD;AACF,SAZD,MAYO,IAAIwD,IAAI,CAACG,SAAL,IAAkB,IAAtB,EAA4B;AACjC,cAAIH,IAAI,CAACM,IAAL,IAAa,IAAb,IAAqBN,IAAI,CAACM,IAAL,KAAc,MAAvC,EAA+C;AAC7CpC,YAAAA,MAAM,CAAC9H,IAAP,CAAY,KAAK+D,OAAL,CAAa6F,IAAI,CAACG,SAAL,EAAb,CAAZ;AACD,WAFD,MAEO;AACLjC,YAAAA,MAAM,CAAC9H,IAAP,CAAYoG,SAAZ;AACD;AACF,SANM,MAMA;AACL0B,UAAAA,MAAM,CAAC9H,IAAP,CAAYoG,SAAZ;AACD;AACF;;AACD,aAAO0B,MAAP;AACD,KA3BM,GAAP;AA4BD,GArrB2C,CAurB5C;;;AACAmC,EAAAA,sBAAsB,CAACE,SAAD,EAAYC,IAAZ,EAAkB;AACtC,QAAIC,SAAS,GAAGF,SAAS,CAACG,YAAV,EAAhB;;AAEA,QAAIC,YAAY,GAAIjF,KAAD,IACjBkF,eAAe,CAACC,OAAD,EAAU,KAAV,EAAkBC,CAAD,IAAOA,CAAC,CAACC,GAAF,CAAMrF,KAAN,CAAxB,CADjB;;AAGA,QAAIsF,WAAW,GAAG,MAAM;AACtB,aAAOP,SAAS,CAACO,WAAV,CAAuBC,OAAD,IAAa;AACxC,YAAIA,OAAO,CAAC5H,MAAR,GAAiB,CAArB,EAAwB;AACtB,eAAK,IAAI4G,KAAT,IAAkBgB,OAAlB,EAA2B;AACzB,gBAAIhB,KAAK,CAACC,MAAV,EAAkB;AAChBD,cAAAA,KAAK,CAAC7I,IAAN,CAAYA,IAAD,IAAU;AACnB,oBACE,KAAK9B,OAAL,CAAa4L,iBAAb,IACA9J,IAAI,CAACC,IAAL,CAAU8J,SAAV,CAAoB,CAApB,EAAuB,CAAvB,MAA8B,GAFhC,EAGE;AACA;AACD;;AACD/J,gBAAAA,IAAI,CAACgK,QAAL,GAAiB,GAAEZ,IAAK,IAAGpJ,IAAI,CAACC,IAAK,EAArC;AACA,uBAAO,KAAK8C,OAAL,CAAa/C,IAAb,CAAP;AACD,eATD;AAUD,aAXD,MAWO,IAAI6I,KAAK,CAACG,WAAV,EAAuB;AAC5B,mBAAKC,sBAAL,CAA4BJ,KAA5B,EAAoC,GAAEO,IAAK,IAAGP,KAAK,CAAC5I,IAAK,EAAzD;AACD;AACF,WAhBqB,CAkBtB;AACA;AACA;;;AACA2J,UAAAA,WAAW;AACZ;;AACD,eAAO,IAAP;AACD,OAzBM,EAyBJL,YAzBI,CAAP;AA0BD,KA3BD;;AA6BA,WAAOK,WAAW,EAAlB;AACD,GA5tB2C,CA8tB5C;AACA;AACA;AACA;AACA;AACA;;;AACAK,EAAAA,MAAM,CAACjK,IAAD,EAAOkK,IAAP,EAAa;AACjB,QACE,KAAKhM,OAAL,CAAaiM,WAAb,IACAnK,IAAI,CAACwH,IAAL,GAAY,KAAKtJ,OAAL,CAAaiM,WAAb,GAA2B,IAA3B,GAAkC,IAFhD,EAGE;AACAD,MAAAA,IAAI,CACF,KAAKhM,OAAL,CAAakM,cAAb,CACGhL,OADH,CACW,cADX,EAC2B0I,IAAI,CAACG,KAAL,CAAWjI,IAAI,CAACwH,IAAL,GAAY,IAAZ,GAAmB,KAA9B,IAAuC,GADlE,EAEGpI,OAFH,CAEW,iBAFX,EAE8B,KAAKlB,OAAL,CAAaiM,WAF3C,CADE,CAAJ;AAKD,KATD,MASO,IAAI,CAAC/M,QAAQ,CAACiN,WAAT,CAAqBrK,IAArB,EAA2B,KAAK9B,OAAL,CAAawB,aAAxC,CAAL,EAA6D;AAClEwK,MAAAA,IAAI,CAAC,KAAKhM,OAAL,CAAaoM,mBAAd,CAAJ;AACD,KAFM,MAEA,IACL,KAAKpM,OAAL,CAAakE,QAAb,IAAyB,IAAzB,IACA,KAAKxB,gBAAL,GAAwBqB,MAAxB,IAAkC,KAAK/D,OAAL,CAAakE,QAF1C,EAGL;AACA8H,MAAAA,IAAI,CACF,KAAKhM,OAAL,CAAaqM,oBAAb,CAAkCnL,OAAlC,CACE,cADF,EAEE,KAAKlB,OAAL,CAAakE,QAFf,CADE,CAAJ;AAMA,WAAKY,IAAL,CAAU,kBAAV,EAA8BhD,IAA9B;AACD,KAXM,MAWA;AACL,WAAK9B,OAAL,CAAa+L,MAAb,CAAoB1K,IAApB,CAAyB,IAAzB,EAA+BS,IAA/B,EAAqCkK,IAArC;AACD;AACF;;AAEDnH,EAAAA,OAAO,CAAC/C,IAAD,EAAO;AACZA,IAAAA,IAAI,CAAC2F,MAAL,GAAc;AACZ6E,MAAAA,IAAI,EAAEpN,QAAQ,CAACqN,MAAT,EADM;AAEZC,MAAAA,QAAQ,EAAE,CAFE;AAGZ;AACA;AACA7E,MAAAA,KAAK,EAAE7F,IAAI,CAACwH,IALA;AAMZ5B,MAAAA,SAAS,EAAE,CANC;AAOZ+E,MAAAA,QAAQ,EAAE,KAAK1E,WAAL,CAAiBjG,IAAjB,CAPE,CAQZ;AACA;AACA;;AAVY,KAAd;AAYA,SAAKvB,KAAL,CAAWO,IAAX,CAAgBgB,IAAhB;AAEAA,IAAAA,IAAI,CAACkB,MAAL,GAAc9D,QAAQ,CAACoE,KAAvB;AAEA,SAAKwB,IAAL,CAAU,WAAV,EAAuBhD,IAAvB;;AAEA,SAAK4K,iBAAL,CAAuB5K,IAAvB;;AAEA,SAAKiK,MAAL,CAAYjK,IAAZ,EAAmBsE,KAAD,IAAW;AAC3B,UAAIA,KAAJ,EAAW;AACTtE,QAAAA,IAAI,CAACc,QAAL,GAAgB,KAAhB;;AACA,aAAK+J,gBAAL,CAAsB,CAAC7K,IAAD,CAAtB,EAA8BsE,KAA9B,EAFS,CAE6B;;AACvC,OAHD,MAGO;AACLtE,QAAAA,IAAI,CAACc,QAAL,GAAgB,IAAhB;;AACA,YAAI,KAAK5C,OAAL,CAAa4M,SAAjB,EAA4B;AAC1B,eAAKC,WAAL,CAAiB/K,IAAjB;AACD,SAJI,CAIH;;AACH;;AACD,WAAKmI,2BAAL;AACD,KAXD;AAYD,GAjyB2C,CAmyB5C;;;AACA6C,EAAAA,YAAY,CAACvM,KAAD,EAAQ;AAClB,SAAK,IAAIuB,IAAT,IAAiBvB,KAAjB,EAAwB;AACtB,WAAKsM,WAAL,CAAiB/K,IAAjB;AACD;;AACD,WAAO,IAAP;AACD;;AAED+K,EAAAA,WAAW,CAAC/K,IAAD,EAAO;AAChB,QAAIA,IAAI,CAACkB,MAAL,KAAgB9D,QAAQ,CAACoE,KAAzB,IAAkCxB,IAAI,CAACc,QAAL,KAAkB,IAAxD,EAA8D;AAC5Dd,MAAAA,IAAI,CAACkB,MAAL,GAAc9D,QAAQ,CAACgE,MAAvB;;AACA,UAAI,KAAKlD,OAAL,CAAa+M,gBAAjB,EAAmC;AACjC,eAAO1H,UAAU,CAAC,MAAM,KAAK2H,YAAL,EAAP,EAA4B,CAA5B,CAAjB,CADiC,CACgB;AAClD;AACF,KALD,MAKO;AACL,YAAM,IAAIrM,KAAJ,CACJ,kFADI,CAAN;AAGD;AACF;;AAED+L,EAAAA,iBAAiB,CAAC5K,IAAD,EAAO;AACtB,QACE,KAAK9B,OAAL,CAAaiN,qBAAb,IACAnL,IAAI,CAACoL,IAAL,CAAUC,KAAV,CAAgB,SAAhB,CADA,IAEArL,IAAI,CAACwH,IAAL,IAAa,KAAKtJ,OAAL,CAAaoN,oBAAb,GAAoC,IAApC,GAA2C,IAH1D,EAIE;AACA,WAAK9N,eAAL,CAAqBwB,IAArB,CAA0BgB,IAA1B;;AACA,aAAOuD,UAAU,CAAC,MAAM,KAAKgI,sBAAL,EAAP,EAAsC,CAAtC,CAAjB,CAFA,CAE2D;AAC5D;AACF;;AAEDA,EAAAA,sBAAsB,GAAG;AACvB,QAAI,KAAK9N,oBAAL,IAA6B,KAAKD,eAAL,CAAqByE,MAArB,KAAgC,CAAjE,EAAoE;AAClE;AACD;;AAED,SAAKxE,oBAAL,GAA4B,IAA5B;;AACA,QAAIuC,IAAI,GAAG,KAAKxC,eAAL,CAAqBgO,KAArB,EAAX;;AACA,WAAO,KAAKC,eAAL,CACLzL,IADK,EAEL,KAAK9B,OAAL,CAAawN,cAFR,EAGL,KAAKxN,OAAL,CAAayN,eAHR,EAIL,KAAKzN,OAAL,CAAa0N,eAJR,EAKL,IALK,EAMJC,OAAD,IAAa;AACX,WAAK7I,IAAL,CAAU,WAAV,EAAuBhD,IAAvB,EAA6B6L,OAA7B;AACA,WAAKpO,oBAAL,GAA4B,KAA5B;AACA,aAAO,KAAK8N,sBAAL,EAAP;AACD,KAVI,CAAP;AAYD,GAt1B2C,CAw1B5C;;;AACAO,EAAAA,UAAU,CAAC9L,IAAD,EAAO;AACf,QAAIA,IAAI,CAACkB,MAAL,KAAgB9D,QAAQ,CAACkE,SAA7B,EAAwC;AACtC,WAAK+F,YAAL,CAAkBrH,IAAlB;AACD;;AACD,SAAKvB,KAAL,GAAasN,OAAO,CAAC,KAAKtN,KAAN,EAAauB,IAAb,CAApB;AAEA,SAAKgD,IAAL,CAAU,aAAV,EAAyBhD,IAAzB;;AACA,QAAI,KAAKvB,KAAL,CAAWwD,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,aAAO,KAAKe,IAAL,CAAU,OAAV,CAAP;AACD;AACF,GAn2B2C,CAq2B5C;;;AACAmC,EAAAA,cAAc,CAAC6G,iBAAD,EAAoB;AAChC;AACA,QAAIA,iBAAiB,IAAI,IAAzB,EAA+B;AAC7BA,MAAAA,iBAAiB,GAAG,KAApB;AACD;;AACD,SAAK,IAAIhM,IAAT,IAAiB,KAAKvB,KAAL,CAAWwN,KAAX,EAAjB,EAAqC;AACnC,UAAIjM,IAAI,CAACkB,MAAL,KAAgB9D,QAAQ,CAACkE,SAAzB,IAAsC0K,iBAA1C,EAA6D;AAC3D,aAAKF,UAAL,CAAgB9L,IAAhB;AACD;AACF;;AACD,WAAO,IAAP;AACD,GAj3B2C,CAm3B5C;AACA;AACA;;;AACAkM,EAAAA,WAAW,CAAClM,IAAD,EAAO4C,KAAP,EAAcD,MAAd,EAAsBwJ,YAAtB,EAAoCC,QAApC,EAA8C;AACvD,WAAO,KAAKX,eAAL,CACLzL,IADK,EAEL4C,KAFK,EAGLD,MAHK,EAILwJ,YAJK,EAKL,IALK,EAML,CAACN,OAAD,EAAUQ,MAAV,KAAqB;AACnB,UAAIA,MAAM,IAAI,IAAd,EAAoB;AAClB;AACA,eAAOD,QAAQ,CAACpM,IAAD,CAAf;AACD,OAHD,MAGO;AACL,YAAI;AAAEsM,UAAAA;AAAF,YAAqB,KAAKpO,OAA9B;;AACA,YAAIoO,cAAc,IAAI,IAAtB,EAA4B;AAC1BA,UAAAA,cAAc,GAAGtM,IAAI,CAACoL,IAAtB;AACD;;AACD,YAAImB,cAAc,GAAGF,MAAM,CAACG,SAAP,CACnBF,cADmB,EAEnB,KAAKpO,OAAL,CAAauO,aAFM,CAArB;;AAIA,YACEH,cAAc,KAAK,YAAnB,IACAA,cAAc,KAAK,WAFrB,EAGE;AACA;AACAC,UAAAA,cAAc,GAAGG,WAAW,CAACC,OAAZ,CAAoB3M,IAAI,CAAC4M,OAAzB,EAAkCL,cAAlC,CAAjB;AACD;;AACD,eAAOH,QAAQ,CAAChP,QAAQ,CAACyP,aAAT,CAAuBN,cAAvB,CAAD,CAAf;AACD;AACF,KA5BI,CAAP;AA8BD;;AAEDd,EAAAA,eAAe,CAACzL,IAAD,EAAO4C,KAAP,EAAcD,MAAd,EAAsBwJ,YAAtB,EAAoCW,cAApC,EAAoDV,QAApD,EAA8D;AAC3E,QAAIW,UAAU,GAAG,IAAIC,UAAJ,EAAjB;;AAEAD,IAAAA,UAAU,CAACE,MAAX,GAAoB,MAAM;AACxBjN,MAAAA,IAAI,CAAC4M,OAAL,GAAeG,UAAU,CAACjG,MAA1B,CADwB,CAGxB;;AACA,UAAI9G,IAAI,CAACoL,IAAL,KAAc,eAAlB,EAAmC;AACjC,YAAIgB,QAAQ,IAAI,IAAhB,EAAsB;AACpBA,UAAAA,QAAQ,CAACW,UAAU,CAACjG,MAAZ,CAAR;AACD;;AACD;AACD;;AAED,WAAKoG,sBAAL,CACElN,IADF,EAEE4C,KAFF,EAGED,MAHF,EAIEwJ,YAJF,EAKEW,cALF,EAMEV,QANF;AAQD,KAnBD;;AAqBAW,IAAAA,UAAU,CAACI,aAAX,CAAyBnN,IAAzB;AACD,GAh7B2C,CAk7B5C;AACA;AACA;AACA;AACA;AACA;;;AACAoN,EAAAA,mBAAmB,CACjBC,QADiB,EAEjBC,QAFiB,EAGjBlB,QAHiB,EAIjBmB,WAJiB,EAKjBC,eAAe,GAAG,IALD,EAMjB;AACA,SAAKxK,IAAL,CAAU,WAAV,EAAuBqK,QAAvB;AACA,SAAKrK,IAAL,CAAU,UAAV,EAAsBqK,QAAtB;;AAEA,QAAI,CAACG,eAAL,EAAsB;AACpB,WAAKxK,IAAL,CAAU,WAAV,EAAuBqK,QAAvB,EAAiCC,QAAjC;AACA,UAAIlB,QAAJ,EAAcA,QAAQ;AACvB,KAHD,MAGO;AACL,UAAIqB,MAAM,GAAIC,SAAD,IAAe;AAC1B,aAAK1K,IAAL,CAAU,WAAV,EAAuBqK,QAAvB,EAAiCK,SAAjC;AACA,YAAItB,QAAJ,EAAcA,QAAQ;AACvB,OAHD;;AAIAiB,MAAAA,QAAQ,CAACT,OAAT,GAAmBU,QAAnB;AAEA,WAAKJ,sBAAL,CACEG,QADF,EAEE,KAAKnP,OAAL,CAAawN,cAFf,EAGE,KAAKxN,OAAL,CAAayN,eAHf,EAIE,KAAKzN,OAAL,CAAaiO,YAJf,EAKE,KAAKjO,OAAL,CAAa4O,cALf,EAMEW,MANF,EAOEF,WAPF;AASD;AACF;;AAEDL,EAAAA,sBAAsB,CACpBlN,IADoB,EAEpB4C,KAFoB,EAGpBD,MAHoB,EAIpBwJ,YAJoB,EAKpBW,cALoB,EAMpBV,QANoB,EAOpBmB,WAPoB,EAQpB;AACA;AACA;AACA,QAAII,GAAG,GAAGjP,QAAQ,CAACqD,aAAT,CAAuB,KAAvB,CAAV;;AAEA,QAAIwL,WAAJ,EAAiB;AACfI,MAAAA,GAAG,CAACJ,WAAJ,GAAkBA,WAAlB;AACD,KAPD,CASA;;;AACAT,IAAAA,cAAc,GACZc,gBAAgB,CAAClP,QAAQ,CAACmP,IAAV,CAAhB,CAAgC,kBAAhC,KAAuD,YAAvD,GACI,KADJ,GAEIf,cAHN;;AAKAa,IAAAA,GAAG,CAACV,MAAJ,GAAa,MAAM;AACjB,UAAIa,QAAQ,GAAI1B,QAAD,IAAcA,QAAQ,CAAC,CAAD,CAArC;;AACA,UAAI,OAAO2B,IAAP,KAAgB,WAAhB,IAA+BA,IAAI,KAAK,IAAxC,IAAgDjB,cAApD,EAAoE;AAClEgB,QAAAA,QAAQ,GAAI1B,QAAD,IACT2B,IAAI,CAACC,OAAL,CAAaL,GAAb,EAAkB,YAAY;AAC5B,iBAAOvB,QAAQ,CAAC2B,IAAI,CAACE,MAAL,CAAY,IAAZ,EAAkB,aAAlB,CAAD,CAAf;AACD,SAFD,CADF;AAID;;AAED,aAAOH,QAAQ,CAAEI,WAAD,IAAiB;AAC/BlO,QAAAA,IAAI,CAAC4C,KAAL,GAAa+K,GAAG,CAAC/K,KAAjB;AACA5C,QAAAA,IAAI,CAAC2C,MAAL,GAAcgL,GAAG,CAAChL,MAAlB;AAEA,YAAIwL,UAAU,GAAG,KAAKjQ,OAAL,CAAakQ,MAAb,CAAoB7O,IAApB,CACf,IADe,EAEfS,IAFe,EAGf4C,KAHe,EAIfD,MAJe,EAKfwJ,YALe,CAAjB;AAQA,YAAIE,MAAM,GAAG3N,QAAQ,CAACqD,aAAT,CAAuB,QAAvB,CAAb;AACA,YAAIsM,GAAG,GAAGhC,MAAM,CAACiC,UAAP,CAAkB,IAAlB,CAAV;AAEAjC,QAAAA,MAAM,CAACzJ,KAAP,GAAeuL,UAAU,CAACI,QAA1B;AACAlC,QAAAA,MAAM,CAAC1J,MAAP,GAAgBwL,UAAU,CAACK,SAA3B;;AAEA,YAAIN,WAAW,GAAG,CAAlB,EAAqB;AACnB7B,UAAAA,MAAM,CAACzJ,KAAP,GAAeuL,UAAU,CAACK,SAA1B;AACAnC,UAAAA,MAAM,CAAC1J,MAAP,GAAgBwL,UAAU,CAACI,QAA3B;AACD;;AAED,gBAAQL,WAAR;AACE,eAAK,CAAL;AACE;AACAG,YAAAA,GAAG,CAACI,SAAJ,CAAcpC,MAAM,CAACzJ,KAArB,EAA4B,CAA5B;AACAyL,YAAAA,GAAG,CAACK,KAAJ,CAAU,CAAC,CAAX,EAAc,CAAd;AACA;;AACF,eAAK,CAAL;AACE;AACAL,YAAAA,GAAG,CAACI,SAAJ,CAAcpC,MAAM,CAACzJ,KAArB,EAA4ByJ,MAAM,CAAC1J,MAAnC;AACA0L,YAAAA,GAAG,CAACM,MAAJ,CAAW7G,IAAI,CAAC8G,EAAhB;AACA;;AACF,eAAK,CAAL;AACE;AACAP,YAAAA,GAAG,CAACI,SAAJ,CAAc,CAAd,EAAiBpC,MAAM,CAAC1J,MAAxB;AACA0L,YAAAA,GAAG,CAACK,KAAJ,CAAU,CAAV,EAAa,CAAC,CAAd;AACA;;AACF,eAAK,CAAL;AACE;AACAL,YAAAA,GAAG,CAACM,MAAJ,CAAW,MAAM7G,IAAI,CAAC8G,EAAtB;AACAP,YAAAA,GAAG,CAACK,KAAJ,CAAU,CAAV,EAAa,CAAC,CAAd;AACA;;AACF,eAAK,CAAL;AACE;AACAL,YAAAA,GAAG,CAACM,MAAJ,CAAW,MAAM7G,IAAI,CAAC8G,EAAtB;AACAP,YAAAA,GAAG,CAACI,SAAJ,CAAc,CAAd,EAAiB,CAACpC,MAAM,CAACzJ,KAAzB;AACA;;AACF,eAAK,CAAL;AACE;AACAyL,YAAAA,GAAG,CAACM,MAAJ,CAAW,MAAM7G,IAAI,CAAC8G,EAAtB;AACAP,YAAAA,GAAG,CAACI,SAAJ,CAAcpC,MAAM,CAAC1J,MAArB,EAA6B,CAAC0J,MAAM,CAACzJ,KAArC;AACAyL,YAAAA,GAAG,CAACK,KAAJ,CAAU,CAAC,CAAX,EAAc,CAAd;AACA;;AACF,eAAK,CAAL;AACE;AACAL,YAAAA,GAAG,CAACM,MAAJ,CAAW,CAAC,GAAD,GAAO7G,IAAI,CAAC8G,EAAvB;AACAP,YAAAA,GAAG,CAACI,SAAJ,CAAc,CAACpC,MAAM,CAAC1J,MAAtB,EAA8B,CAA9B;AACA;AApCJ,SAvB+B,CA8D/B;;;AACAkM,QAAAA,eAAe,CACbR,GADa,EAEbV,GAFa,EAGbQ,UAAU,CAACW,IAAX,IAAmB,IAAnB,GAA0BX,UAAU,CAACW,IAArC,GAA4C,CAH/B,EAIbX,UAAU,CAACY,IAAX,IAAmB,IAAnB,GAA0BZ,UAAU,CAACY,IAArC,GAA4C,CAJ/B,EAKbZ,UAAU,CAACa,QALE,EAMbb,UAAU,CAACc,SANE,EAObd,UAAU,CAACe,IAAX,IAAmB,IAAnB,GAA0Bf,UAAU,CAACe,IAArC,GAA4C,CAP/B,EAQbf,UAAU,CAACgB,IAAX,IAAmB,IAAnB,GAA0BhB,UAAU,CAACgB,IAArC,GAA4C,CAR/B,EASbhB,UAAU,CAACI,QATE,EAUbJ,UAAU,CAACK,SAVE,CAAf;AAaA,YAAId,SAAS,GAAGrB,MAAM,CAACG,SAAP,CAAiB,WAAjB,CAAhB;;AAEA,YAAIJ,QAAQ,IAAI,IAAhB,EAAsB;AACpB,iBAAOA,QAAQ,CAACsB,SAAD,EAAYrB,MAAZ,CAAf;AACD;AACF,OAjFc,CAAf;AAkFD,KA3FD;;AA6FA,QAAID,QAAQ,IAAI,IAAhB,EAAsB;AACpBuB,MAAAA,GAAG,CAACyB,OAAJ,GAAchD,QAAd;AACD;;AAED,WAAQuB,GAAG,CAAC0B,GAAJ,GAAUrP,IAAI,CAAC4M,OAAvB;AACD,GAjlC2C,CAmlC5C;;;AACA1B,EAAAA,YAAY,GAAG;AACb,QAAI;AAAEoE,MAAAA;AAAF,QAAsB,KAAKpR,OAA/B;AACA,QAAIqR,gBAAgB,GAAG,KAAKlO,iBAAL,GAAyBY,MAAhD;AACA,QAAI2B,CAAC,GAAG2L,gBAAR,CAHa,CAKb;;AACA,QAAIA,gBAAgB,IAAID,eAAxB,EAAyC;AACvC;AACD;;AAED,QAAIE,WAAW,GAAG,KAAKrO,cAAL,EAAlB;;AAEA,QAAI,EAAEqO,WAAW,CAACvN,MAAZ,GAAqB,CAAvB,CAAJ,EAA+B;AAC7B;AACD;;AAED,QAAI,KAAK/D,OAAL,CAAa0B,cAAjB,EAAiC;AAC/B;AACA,aAAO,KAAK6P,YAAL,CACLD,WAAW,CAACvD,KAAZ,CAAkB,CAAlB,EAAqBqD,eAAe,GAAGC,gBAAvC,CADK,CAAP;AAGD,KALD,MAKO;AACL,aAAO3L,CAAC,GAAG0L,eAAX,EAA4B;AAC1B,YAAI,CAACE,WAAW,CAACvN,MAAjB,EAAyB;AACvB;AACD,SAHyB,CAGxB;;;AACF,aAAKyN,WAAL,CAAiBF,WAAW,CAAChE,KAAZ,EAAjB;AACA5H,QAAAA,CAAC;AACF;AACF;AACF,GAlnC2C,CAonC5C;;;AACA8L,EAAAA,WAAW,CAAC1P,IAAD,EAAO;AAChB,WAAO,KAAKyP,YAAL,CAAkB,CAACzP,IAAD,CAAlB,CAAP;AACD,GAvnC2C,CAynC5C;;;AACAyP,EAAAA,YAAY,CAAChR,KAAD,EAAQ;AAClB,SAAK,IAAIuB,IAAT,IAAiBvB,KAAjB,EAAwB;AACtBuB,MAAAA,IAAI,CAAC2P,UAAL,GAAkB,IAAlB,CADsB,CACE;;AACxB3P,MAAAA,IAAI,CAACkB,MAAL,GAAc9D,QAAQ,CAACkE,SAAvB;AAEA,WAAK0B,IAAL,CAAU,YAAV,EAAwBhD,IAAxB;AACD;;AAED,QAAI,KAAK9B,OAAL,CAAa0B,cAAjB,EAAiC;AAC/B,WAAKoD,IAAL,CAAU,oBAAV,EAAgCvE,KAAhC;AACD;;AAED,WAAO,KAAKmR,WAAL,CAAiBnR,KAAjB,CAAP;AACD;;AAEDoR,EAAAA,gBAAgB,CAACC,GAAD,EAAM;AACpB,QAAIrR,KAAJ;AACA,WAAQA,KAAK,GAAG,KAAKA,KAAL,CACboC,MADa,CACLb,IAAD,IAAUA,IAAI,CAAC8P,GAAL,KAAaA,GADjB,EAEb/O,GAFa,CAERf,IAAD,IAAUA,IAFD,CAAhB;AAGD,GA9oC2C,CAgpC5C;AACA;AACA;AACA;;;AACAqH,EAAAA,YAAY,CAACrH,IAAD,EAAO;AACjB,QAAIA,IAAI,CAACkB,MAAL,KAAgB9D,QAAQ,CAACkE,SAA7B,EAAwC;AACtC,UAAIyO,YAAY,GAAG,KAAKF,gBAAL,CAAsB7P,IAAI,CAAC8P,GAA3B,CAAnB;;AACA,WAAK,IAAIE,WAAT,IAAwBD,YAAxB,EAAsC;AACpCC,QAAAA,WAAW,CAAC9O,MAAZ,GAAqB9D,QAAQ,CAAC6S,QAA9B;AACD;;AACD,UAAI,OAAOjQ,IAAI,CAAC8P,GAAZ,KAAoB,WAAxB,EAAqC;AACnC9P,QAAAA,IAAI,CAAC8P,GAAL,CAASI,KAAT;AACD;;AACD,WAAK,IAAIF,WAAT,IAAwBD,YAAxB,EAAsC;AACpC,aAAK/M,IAAL,CAAU,UAAV,EAAsBgN,WAAtB;AACD;;AACD,UAAI,KAAK9R,OAAL,CAAa0B,cAAjB,EAAiC;AAC/B,aAAKoD,IAAL,CAAU,kBAAV,EAA8B+M,YAA9B;AACD;AACF,KAdD,MAcO,IACL/P,IAAI,CAACkB,MAAL,KAAgB9D,QAAQ,CAACoE,KAAzB,IACAxB,IAAI,CAACkB,MAAL,KAAgB9D,QAAQ,CAACgE,MAFpB,EAGL;AACApB,MAAAA,IAAI,CAACkB,MAAL,GAAc9D,QAAQ,CAAC6S,QAAvB;AACA,WAAKjN,IAAL,CAAU,UAAV,EAAsBhD,IAAtB;;AACA,UAAI,KAAK9B,OAAL,CAAa0B,cAAjB,EAAiC;AAC/B,aAAKoD,IAAL,CAAU,kBAAV,EAA8B,CAAChD,IAAD,CAA9B;AACD;AACF;;AAED,QAAI,KAAK9B,OAAL,CAAa+M,gBAAjB,EAAmC;AACjC,aAAO,KAAKC,YAAL,EAAP;AACD;AACF;;AAEDiF,EAAAA,aAAa,CAACC,MAAD,EAAS,GAAGC,IAAZ,EAAkB;AAC7B,QAAI,OAAOD,MAAP,KAAkB,UAAtB,EAAkC;AAChC,aAAOA,MAAM,CAACE,KAAP,CAAa,IAAb,EAAmBD,IAAnB,CAAP;AACD;;AACD,WAAOD,MAAP;AACD;;AAEDG,EAAAA,UAAU,CAACvQ,IAAD,EAAO;AACf,WAAO,KAAK4P,WAAL,CAAiB,CAAC5P,IAAD,CAAjB,CAAP;AACD;;AAED4P,EAAAA,WAAW,CAACnR,KAAD,EAAQ;AACjB,SAAK+R,eAAL,CAAqB/R,KAArB,EAA6BgS,gBAAD,IAAsB;AAChD,UAAI,KAAKvS,OAAL,CAAa2B,QAAjB,EAA2B;AACzB;AACA;AACA,YAAI6Q,eAAe,GAAGD,gBAAgB,CAAC,CAAD,CAAtC;AACAhS,QAAAA,KAAK,CAAC,CAAD,CAAL,CAASkH,MAAT,CAAgBgL,OAAhB,GACE,KAAKzS,OAAL,CAAa2B,QAAb,KACC,KAAK3B,OAAL,CAAa0S,aAAb,IACCF,eAAe,CAAClJ,IAAhB,GAAuB,KAAKtJ,OAAL,CAAa2S,SAFtC,CADF;AAIApS,QAAAA,KAAK,CAAC,CAAD,CAAL,CAASkH,MAAT,CAAgBmL,eAAhB,GAAkChJ,IAAI,CAACiJ,IAAL,CAChCL,eAAe,CAAClJ,IAAhB,GAAuB,KAAKtJ,OAAL,CAAa2S,SADJ,CAAlC;AAGD;;AAED,UAAIpS,KAAK,CAAC,CAAD,CAAL,CAASkH,MAAT,CAAgBgL,OAApB,EAA6B;AAC3B;AAEA;AACA;AACA,YAAI3Q,IAAI,GAAGvB,KAAK,CAAC,CAAD,CAAhB;AACA,YAAIiS,eAAe,GAAGD,gBAAgB,CAAC,CAAD,CAAtC;AACA,YAAIO,iBAAiB,GAAG,CAAxB;AAEAhR,QAAAA,IAAI,CAAC2F,MAAL,CAAYsL,MAAZ,GAAqB,EAArB;;AAEA,YAAIC,eAAe,GAAG,MAAM;AAC1B,cAAIC,UAAU,GAAG,CAAjB,CAD0B,CAG1B;;AACA,iBAAOnR,IAAI,CAAC2F,MAAL,CAAYsL,MAAZ,CAAmBE,UAAnB,MAAmC/L,SAA1C,EAAqD;AACnD+L,YAAAA,UAAU;AACX,WANyB,CAQ1B;;;AACA,cAAIA,UAAU,IAAInR,IAAI,CAAC2F,MAAL,CAAYmL,eAA9B,EAA+C;AAE/CE,UAAAA,iBAAiB;AAEjB,cAAII,KAAK,GAAGD,UAAU,GAAG,KAAKjT,OAAL,CAAa2S,SAAtC;AACA,cAAIQ,GAAG,GAAGvJ,IAAI,CAACwJ,GAAL,CACRF,KAAK,GAAG,KAAKlT,OAAL,CAAa2S,SADb,EAERH,eAAe,CAAClJ,IAFR,CAAV;AAKA,cAAI+J,SAAS,GAAG;AACdtR,YAAAA,IAAI,EAAE,KAAK6F,aAAL,CAAmB,CAAnB,CADQ;AAEd0L,YAAAA,IAAI,EAAEd,eAAe,CAACe,WAAhB,GACFf,eAAe,CAACe,WAAhB,CAA4BL,KAA5B,EAAmCC,GAAnC,CADE,GAEFX,eAAe,CAACzE,KAAhB,CAAsBmF,KAAtB,EAA6BC,GAA7B,CAJU;AAKd1G,YAAAA,QAAQ,EAAE3K,IAAI,CAAC2F,MAAL,CAAYgF,QALR;AAMdwG,YAAAA,UAAU,EAAEA;AANE,WAAhB;AASAnR,UAAAA,IAAI,CAAC2F,MAAL,CAAYsL,MAAZ,CAAmBE,UAAnB,IAAiC;AAC/BnR,YAAAA,IAAI,EAAEA,IADyB;AAE/B0R,YAAAA,KAAK,EAAEP,UAFwB;AAG/BI,YAAAA,SAAS,EAAEA,SAHoB;AAGT;AACtBrQ,YAAAA,MAAM,EAAE9D,QAAQ,CAACkE,SAJc;AAK/BoJ,YAAAA,QAAQ,EAAE,CALqB;AAM/BiH,YAAAA,OAAO,EAAE,CANsB,CAMnB;;AANmB,WAAjC;;AASA,eAAKC,WAAL,CAAiBnT,KAAjB,EAAwB,CAAC8S,SAAD,CAAxB;AACD,SAtCD;;AAwCAvR,QAAAA,IAAI,CAAC2F,MAAL,CAAYkM,mBAAZ,GAAkC,CAACC,KAAD,EAAQC,QAAR,KAAqB;AACrD,cAAIC,WAAW,GAAG,IAAlB;AACAF,UAAAA,KAAK,CAAC5Q,MAAN,GAAe9D,QAAQ,CAAC6U,OAAxB,CAFqD,CAIrD;;AACAH,UAAAA,KAAK,CAACP,SAAN,GAAkB,IAAlB,CALqD,CAMrD;;AACAO,UAAAA,KAAK,CAAChC,GAAN,GAAY,IAAZ;;AAEA,eAAK,IAAIlM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5D,IAAI,CAAC2F,MAAL,CAAYmL,eAAhC,EAAiDlN,CAAC,EAAlD,EAAsD;AACpD,gBAAI5D,IAAI,CAAC2F,MAAL,CAAYsL,MAAZ,CAAmBrN,CAAnB,MAA0BwB,SAA9B,EAAyC;AACvC,qBAAO8L,eAAe,EAAtB;AACD;;AACD,gBAAIlR,IAAI,CAAC2F,MAAL,CAAYsL,MAAZ,CAAmBrN,CAAnB,EAAsB1C,MAAtB,KAAiC9D,QAAQ,CAAC6U,OAA9C,EAAuD;AACrDD,cAAAA,WAAW,GAAG,KAAd;AACD;AACF;;AAED,cAAIA,WAAJ,EAAiB;AACf,iBAAK9T,OAAL,CAAagU,cAAb,CAA4BlS,IAA5B,EAAkC,MAAM;AACtC,mBAAKmS,SAAL,CAAe1T,KAAf,EAAsBsT,QAAtB,EAAgC,IAAhC;AACD,aAFD;AAGD;AACF,SAvBD;;AAyBA,YAAI,KAAK7T,OAAL,CAAakU,oBAAjB,EAAuC;AACrC,eAAK,IAAIxO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5D,IAAI,CAAC2F,MAAL,CAAYmL,eAAhC,EAAiDlN,CAAC,EAAlD,EAAsD;AACpDsN,YAAAA,eAAe;AAChB;AACF,SAJD,MAIO;AACLA,UAAAA,eAAe;AAChB;AACF,OAnFD,MAmFO;AACL,YAAImB,UAAU,GAAG,EAAjB;;AACA,aAAK,IAAIzO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnF,KAAK,CAACwD,MAA1B,EAAkC2B,CAAC,EAAnC,EAAuC;AACrCyO,UAAAA,UAAU,CAACzO,CAAD,CAAV,GAAgB;AACd3D,YAAAA,IAAI,EAAE,KAAK6F,aAAL,CAAmBlC,CAAnB,CADQ;AAEd4N,YAAAA,IAAI,EAAEf,gBAAgB,CAAC7M,CAAD,CAFR;AAGd+G,YAAAA,QAAQ,EAAElM,KAAK,CAACmF,CAAD,CAAL,CAAS+B,MAAT,CAAgBgF;AAHZ,WAAhB;AAKD;;AACD,aAAKiH,WAAL,CAAiBnT,KAAjB,EAAwB4T,UAAxB;AACD;AACF,KA5GD;AA6GD,GA5yC2C,CA8yC5C;;;AACAC,EAAAA,SAAS,CAACtS,IAAD,EAAO8P,GAAP,EAAY;AACnB,SAAK,IAAIlM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5D,IAAI,CAAC2F,MAAL,CAAYmL,eAAhC,EAAiDlN,CAAC,EAAlD,EAAsD;AACpD,UACE5D,IAAI,CAAC2F,MAAL,CAAYsL,MAAZ,CAAmBrN,CAAnB,MAA0BwB,SAA1B,IACApF,IAAI,CAAC2F,MAAL,CAAYsL,MAAZ,CAAmBrN,CAAnB,EAAsBkM,GAAtB,KAA8BA,GAFhC,EAGE;AACA,eAAO9P,IAAI,CAAC2F,MAAL,CAAYsL,MAAZ,CAAmBrN,CAAnB,CAAP;AACD;AACF;AACF,GAxzC2C,CA0zC5C;AACA;AACA;;;AACAgO,EAAAA,WAAW,CAACnT,KAAD,EAAQ4T,UAAR,EAAoB;AAC7B,QAAIvC,GAAG,GAAG,IAAIyC,cAAJ,EAAV,CAD6B,CAG7B;;AACA,SAAK,IAAIvS,IAAT,IAAiBvB,KAAjB,EAAwB;AACtBuB,MAAAA,IAAI,CAAC8P,GAAL,GAAWA,GAAX;AACD;;AACD,QAAIrR,KAAK,CAAC,CAAD,CAAL,CAASkH,MAAT,CAAgBgL,OAApB,EAA6B;AAC3B;AACAlS,MAAAA,KAAK,CAAC,CAAD,CAAL,CAASkH,MAAT,CAAgBsL,MAAhB,CAAuBoB,UAAU,CAAC,CAAD,CAAV,CAAclB,UAArC,EAAiDrB,GAAjD,GAAuDA,GAAvD;AACD;;AAED,QAAI5P,MAAM,GAAG,KAAKiQ,aAAL,CAAmB,KAAKjS,OAAL,CAAagC,MAAhC,EAAwCzB,KAAxC,CAAb;AACA,QAAIe,GAAG,GAAG,KAAK2Q,aAAL,CAAmB,KAAKjS,OAAL,CAAasB,GAAhC,EAAqCf,KAArC,CAAV;AACAqR,IAAAA,GAAG,CAAC0C,IAAJ,CAAStS,MAAT,EAAiBV,GAAjB,EAAsB,IAAtB,EAd6B,CAgB7B;;AACA,QAAIiT,OAAO,GAAG,KAAKtC,aAAL,CAAmB,KAAKjS,OAAL,CAAauU,OAAhC,EAAyChU,KAAzC,CAAd;AACA,QAAIgU,OAAJ,EAAa3C,GAAG,CAAC2C,OAAJ,GAAc,KAAKtC,aAAL,CAAmB,KAAKjS,OAAL,CAAauU,OAAhC,EAAyChU,KAAzC,CAAd,CAlBgB,CAoB7B;;AACAqR,IAAAA,GAAG,CAAC4C,eAAJ,GAAsB,CAAC,CAAC,KAAKxU,OAAL,CAAawU,eAArC;;AAEA5C,IAAAA,GAAG,CAAC7C,MAAJ,GAAcxJ,CAAD,IAAO;AAClB,WAAKkP,kBAAL,CAAwBlU,KAAxB,EAA+BqR,GAA/B,EAAoCrM,CAApC;AACD,KAFD;;AAIAqM,IAAAA,GAAG,CAAC8C,SAAJ,GAAgB,MAAM;AACpB,WAAKC,kBAAL,CACEpU,KADF,EAEEqR,GAFF,EAGG,0BAAyB,KAAK5R,OAAL,CAAauU,OAAb,GAAuB,IAAK,UAHxD;AAKD,KAND;;AAQA3C,IAAAA,GAAG,CAACV,OAAJ,GAAc,MAAM;AAClB,WAAKyD,kBAAL,CAAwBpU,KAAxB,EAA+BqR,GAA/B;AACD,KAFD,CAnC6B,CAuC7B;;;AACA,QAAIgD,WAAW,GAAGhD,GAAG,CAACnK,MAAJ,IAAc,IAAd,GAAqBmK,GAAG,CAACnK,MAAzB,GAAkCmK,GAApD;;AACAgD,IAAAA,WAAW,CAACC,UAAZ,GAA0BtP,CAAD,IACvB,KAAKuP,0BAAL,CAAgCvU,KAAhC,EAAuCqR,GAAvC,EAA4CrM,CAA5C,CADF;;AAGA,QAAIwP,OAAO,GAAG;AACZC,MAAAA,MAAM,EAAE,kBADI;AAEZ,uBAAiB,UAFL;AAGZ,0BAAoB;AAHR,KAAd;;AAMA,QAAI,KAAKhV,OAAL,CAAa+U,OAAjB,EAA0B;AACxB7V,MAAAA,QAAQ,CAACM,MAAT,CAAgBuV,OAAhB,EAAyB,KAAK/U,OAAL,CAAa+U,OAAtC;AACD;;AAED,SAAK,IAAIE,UAAT,IAAuBF,OAAvB,EAAgC;AAC9B,UAAIG,WAAW,GAAGH,OAAO,CAACE,UAAD,CAAzB;;AACA,UAAIC,WAAJ,EAAiB;AACftD,QAAAA,GAAG,CAACuD,gBAAJ,CAAqBF,UAArB,EAAiCC,WAAjC;AACD;AACF;;AAED,QAAIE,QAAQ,GAAG,IAAIC,QAAJ,EAAf,CA7D6B,CA+D7B;;AACA,QAAI,KAAKrV,OAAL,CAAasV,MAAjB,EAAyB;AACvB,UAAIC,gBAAgB,GAAG,KAAKvV,OAAL,CAAasV,MAApC;;AACA,UAAI,OAAOC,gBAAP,KAA4B,UAAhC,EAA4C;AAC1CA,QAAAA,gBAAgB,GAAGA,gBAAgB,CAAClU,IAAjB,CACjB,IADiB,EAEjBd,KAFiB,EAGjBqR,GAHiB,EAIjBrR,KAAK,CAAC,CAAD,CAAL,CAASkH,MAAT,CAAgBgL,OAAhB,GAA0B,KAAK2B,SAAL,CAAe7T,KAAK,CAAC,CAAD,CAApB,EAAyBqR,GAAzB,CAA1B,GAA0D,IAJzC,CAAnB;AAMD;;AAED,WAAK,IAAIhS,GAAT,IAAgB2V,gBAAhB,EAAkC;AAChC,YAAIC,KAAK,GAAGD,gBAAgB,CAAC3V,GAAD,CAA5B;;AACA,YAAI6V,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAJ,EAA0B;AACxB;AACA;AACA;AACA,eAAK,IAAI9P,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8P,KAAK,CAACzR,MAA1B,EAAkC2B,CAAC,EAAnC,EAAuC;AACrC0P,YAAAA,QAAQ,CAACO,MAAT,CAAgB/V,GAAhB,EAAqB4V,KAAK,CAAC9P,CAAD,CAA1B;AACD;AACF,SAPD,MAOO;AACL0P,UAAAA,QAAQ,CAACO,MAAT,CAAgB/V,GAAhB,EAAqB4V,KAArB;AACD;AACF;AACF,KAxF4B,CA0F7B;;;AACA,SAAK,IAAI1T,IAAT,IAAiBvB,KAAjB,EAAwB;AACtB,WAAKuE,IAAL,CAAU,SAAV,EAAqBhD,IAArB,EAA2B8P,GAA3B,EAAgCwD,QAAhC;AACD;;AACD,QAAI,KAAKpV,OAAL,CAAa0B,cAAjB,EAAiC;AAC/B,WAAKoD,IAAL,CAAU,iBAAV,EAA6BvE,KAA7B,EAAoCqR,GAApC,EAAyCwD,QAAzC;AACD;;AAED,SAAKQ,mBAAL,CAAyBR,QAAzB,EAlG6B,CAoG7B;AACA;;;AACA,SAAK,IAAI1P,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyO,UAAU,CAACpQ,MAA/B,EAAuC2B,CAAC,EAAxC,EAA4C;AAC1C,UAAI2N,SAAS,GAAGc,UAAU,CAACzO,CAAD,CAA1B;AACA0P,MAAAA,QAAQ,CAACO,MAAT,CAAgBtC,SAAS,CAACtR,IAA1B,EAAgCsR,SAAS,CAACC,IAA1C,EAAgDD,SAAS,CAAC5G,QAA1D;AACD;;AAED,SAAKoJ,aAAL,CAAmBjE,GAAnB,EAAwBwD,QAAxB,EAAkC7U,KAAlC;AACD,GAz6C2C,CA26C5C;;;AACA+R,EAAAA,eAAe,CAAC/R,KAAD,EAAQyL,IAAR,EAAc;AAC3B,QAAIuG,gBAAgB,GAAG,EAAvB,CAD2B,CAE3B;;AACA,QAAIuD,WAAW,GAAG,CAAlB;;AACA,SAAK,IAAIpQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnF,KAAK,CAACwD,MAA1B,EAAkC2B,CAAC,EAAnC,EAAuC;AACrC,WAAK1F,OAAL,CAAa+V,aAAb,CAA2B1U,IAA3B,CAAgC,IAAhC,EAAsCd,KAAK,CAACmF,CAAD,CAA3C,EAAiD8M,eAAD,IAAqB;AACnED,QAAAA,gBAAgB,CAAC7M,CAAD,CAAhB,GAAsB8M,eAAtB;;AACA,YAAI,EAAEsD,WAAF,KAAkBvV,KAAK,CAACwD,MAA5B,EAAoC;AAClCiI,UAAAA,IAAI,CAACuG,gBAAD,CAAJ;AACD;AACF,OALD;AAMD;AACF,GAx7C2C,CA07C5C;;;AACAqD,EAAAA,mBAAmB,CAACR,QAAD,EAAW;AAC5B;AACA,QAAI,KAAKjV,OAAL,CAAaqD,OAAb,KAAyB,MAA7B,EAAqC;AACnC,WAAK,IAAIwS,KAAT,IAAkB,KAAK7V,OAAL,CAAa8V,gBAAb,CAChB,iCADgB,CAAlB,EAEG;AACD,YAAIC,SAAS,GAAGF,KAAK,CAACzU,YAAN,CAAmB,MAAnB,CAAhB;AACA,YAAI4U,SAAS,GAAGH,KAAK,CAACzU,YAAN,CAAmB,MAAnB,CAAhB;AACA,YAAI4U,SAAJ,EAAeA,SAAS,GAAGA,SAAS,CAACC,WAAV,EAAZ,CAHd,CAKD;;AACA,YAAI,OAAOF,SAAP,KAAqB,WAArB,IAAoCA,SAAS,KAAK,IAAtD,EAA4D;;AAE5D,YAAIF,KAAK,CAACxS,OAAN,KAAkB,QAAlB,IAA8BwS,KAAK,CAACK,YAAN,CAAmB,UAAnB,CAAlC,EAAkE;AAChE;AACA,eAAK,IAAInE,MAAT,IAAmB8D,KAAK,CAAChW,OAAzB,EAAkC;AAChC,gBAAIkS,MAAM,CAACoE,QAAX,EAAqB;AACnBlB,cAAAA,QAAQ,CAACO,MAAT,CAAgBO,SAAhB,EAA2BhE,MAAM,CAACsD,KAAlC;AACD;AACF;AACF,SAPD,MAOO,IACL,CAACW,SAAD,IACCA,SAAS,KAAK,UAAd,IAA4BA,SAAS,KAAK,OAD3C,IAEAH,KAAK,CAACO,OAHD,EAIL;AACAnB,UAAAA,QAAQ,CAACO,MAAT,CAAgBO,SAAhB,EAA2BF,KAAK,CAACR,KAAjC;AACD;AACF;AACF;AACF,GAx9C2C,CA09C5C;AACA;;;AACAV,EAAAA,0BAA0B,CAACvU,KAAD,EAAQqR,GAAR,EAAarM,CAAb,EAAgB;AACxC,QAAI,CAAChF,KAAK,CAAC,CAAD,CAAL,CAASkH,MAAT,CAAgBgL,OAArB,EAA8B;AAC5B;AACA,WAAK,IAAI3Q,IAAT,IAAiBvB,KAAjB,EAAwB;AACtB,YACEuB,IAAI,CAAC2F,MAAL,CAAYE,KAAZ,IACA7F,IAAI,CAAC2F,MAAL,CAAYC,SADZ,IAEA5F,IAAI,CAAC2F,MAAL,CAAYC,SAAZ,IAAyB5F,IAAI,CAAC2F,MAAL,CAAYE,KAHvC,EAIE;AACA;AACA;AACA;AACA;AACD;;AAED,YAAIpC,CAAJ,EAAO;AACLzD,UAAAA,IAAI,CAAC2F,MAAL,CAAY+E,QAAZ,GAAwB,MAAMjH,CAAC,CAACiR,MAAT,GAAmBjR,CAAC,CAACoC,KAA5C;AACA7F,UAAAA,IAAI,CAAC2F,MAAL,CAAYE,KAAZ,GAAoBpC,CAAC,CAACoC,KAAtB;AACA7F,UAAAA,IAAI,CAAC2F,MAAL,CAAYC,SAAZ,GAAwBnC,CAAC,CAACiR,MAA1B;AACD,SAJD,MAIO;AACL;AACA1U,UAAAA,IAAI,CAAC2F,MAAL,CAAY+E,QAAZ,GAAuB,GAAvB;AACA1K,UAAAA,IAAI,CAAC2F,MAAL,CAAYC,SAAZ,GAAwB5F,IAAI,CAAC2F,MAAL,CAAYE,KAApC;AACD;;AAED,aAAK7C,IAAL,CACE,gBADF,EAEEhD,IAFF,EAGEA,IAAI,CAAC2F,MAAL,CAAY+E,QAHd,EAIE1K,IAAI,CAAC2F,MAAL,CAAYC,SAJd;AAMD;AACF,KA/BD,MA+BO;AACL;AAEA;AACA;AACA,UAAI5F,IAAI,GAAGvB,KAAK,CAAC,CAAD,CAAhB,CALK,CAOL;AACA;;AACA,UAAIqT,KAAK,GAAG,KAAKQ,SAAL,CAAetS,IAAf,EAAqB8P,GAArB,CAAZ;;AAEA,UAAIrM,CAAJ,EAAO;AACLqO,QAAAA,KAAK,CAACpH,QAAN,GAAkB,MAAMjH,CAAC,CAACiR,MAAT,GAAmBjR,CAAC,CAACoC,KAAtC;AACAiM,QAAAA,KAAK,CAACjM,KAAN,GAAcpC,CAAC,CAACoC,KAAhB;AACAiM,QAAAA,KAAK,CAAClM,SAAN,GAAkBnC,CAAC,CAACiR,MAApB;AACD,OAJD,MAIO;AACL;AACA5C,QAAAA,KAAK,CAACpH,QAAN,GAAiB,GAAjB;AACAoH,QAAAA,KAAK,CAAClM,SAAN,GAAkBkM,KAAK,CAACjM,KAAxB;AACD,OAnBI,CAqBL;;;AACA7F,MAAAA,IAAI,CAAC2F,MAAL,CAAY+E,QAAZ,GAAuB,CAAvB;AACA1K,MAAAA,IAAI,CAAC2F,MAAL,CAAYE,KAAZ,GAAoB,CAApB;AACA7F,MAAAA,IAAI,CAAC2F,MAAL,CAAYC,SAAZ,GAAwB,CAAxB;;AACA,WAAK,IAAIhC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5D,IAAI,CAAC2F,MAAL,CAAYmL,eAAhC,EAAiDlN,CAAC,EAAlD,EAAsD;AACpD,YACE5D,IAAI,CAAC2F,MAAL,CAAYsL,MAAZ,CAAmBrN,CAAnB,KACA,OAAO5D,IAAI,CAAC2F,MAAL,CAAYsL,MAAZ,CAAmBrN,CAAnB,EAAsB8G,QAA7B,KAA0C,WAF5C,EAGE;AACA1K,UAAAA,IAAI,CAAC2F,MAAL,CAAY+E,QAAZ,IAAwB1K,IAAI,CAAC2F,MAAL,CAAYsL,MAAZ,CAAmBrN,CAAnB,EAAsB8G,QAA9C;AACA1K,UAAAA,IAAI,CAAC2F,MAAL,CAAYE,KAAZ,IAAqB7F,IAAI,CAAC2F,MAAL,CAAYsL,MAAZ,CAAmBrN,CAAnB,EAAsBiC,KAA3C;AACA7F,UAAAA,IAAI,CAAC2F,MAAL,CAAYC,SAAZ,IAAyB5F,IAAI,CAAC2F,MAAL,CAAYsL,MAAZ,CAAmBrN,CAAnB,EAAsBgC,SAA/C;AACD;AACF,OAlCI,CAmCL;AACA;;;AACA5F,MAAAA,IAAI,CAAC2F,MAAL,CAAY+E,QAAZ,GAAuB1K,IAAI,CAAC2F,MAAL,CAAY+E,QAAZ,GAAuB1K,IAAI,CAAC2F,MAAL,CAAYmL,eAA1D;AAEA,WAAK9N,IAAL,CACE,gBADF,EAEEhD,IAFF,EAGEA,IAAI,CAAC2F,MAAL,CAAY+E,QAHd,EAIE1K,IAAI,CAAC2F,MAAL,CAAYC,SAJd;AAMD;AACF;;AAED+M,EAAAA,kBAAkB,CAAClU,KAAD,EAAQqR,GAAR,EAAarM,CAAb,EAAgB;AAChC,QAAIsO,QAAJ;;AAEA,QAAItT,KAAK,CAAC,CAAD,CAAL,CAASyC,MAAT,KAAoB9D,QAAQ,CAAC6S,QAAjC,EAA2C;AACzC;AACD;;AAED,QAAIH,GAAG,CAAC6E,UAAJ,KAAmB,CAAvB,EAA0B;AACxB;AACD;;AAED,QAAI7E,GAAG,CAAC8E,YAAJ,KAAqB,aAArB,IAAsC9E,GAAG,CAAC8E,YAAJ,KAAqB,MAA/D,EAAuE;AACrE7C,MAAAA,QAAQ,GAAGjC,GAAG,CAAC+E,YAAf;;AAEA,UACE/E,GAAG,CAACgF,iBAAJ,CAAsB,cAAtB,KACA,CAAChF,GAAG,CAACgF,iBAAJ,CAAsB,cAAtB,EAAsCxP,OAAtC,CAA8C,kBAA9C,CAFH,EAGE;AACA,YAAI;AACFyM,UAAAA,QAAQ,GAAGgD,IAAI,CAACC,KAAL,CAAWjD,QAAX,CAAX;AACD,SAFD,CAEE,OAAOzN,KAAP,EAAc;AACdb,UAAAA,CAAC,GAAGa,KAAJ;AACAyN,UAAAA,QAAQ,GAAG,oCAAX;AACD;AACF;AACF;;AAED,SAAKiB,0BAAL,CAAgCvU,KAAhC,EAAuCqR,GAAvC;;AAEA,QAAI,EAAE,OAAOA,GAAG,CAAC5O,MAAX,IAAqB4O,GAAG,CAAC5O,MAAJ,GAAa,GAApC,CAAJ,EAA8C;AAC5C,WAAK2R,kBAAL,CAAwBpU,KAAxB,EAA+BqR,GAA/B,EAAoCiC,QAApC;AACD,KAFD,MAEO;AACL,UAAItT,KAAK,CAAC,CAAD,CAAL,CAASkH,MAAT,CAAgBgL,OAApB,EAA6B;AAC3BlS,QAAAA,KAAK,CAAC,CAAD,CAAL,CAASkH,MAAT,CAAgBkM,mBAAhB,CACE,KAAKS,SAAL,CAAe7T,KAAK,CAAC,CAAD,CAApB,EAAyBqR,GAAzB,CADF,EAEEiC,QAFF;AAID,OALD,MAKO;AACL,aAAKI,SAAL,CAAe1T,KAAf,EAAsBsT,QAAtB,EAAgCtO,CAAhC;AACD;AACF;AACF;;AAEDoP,EAAAA,kBAAkB,CAACpU,KAAD,EAAQqR,GAAR,EAAaiC,QAAb,EAAuB;AACvC,QAAItT,KAAK,CAAC,CAAD,CAAL,CAASyC,MAAT,KAAoB9D,QAAQ,CAAC6S,QAAjC,EAA2C;AACzC;AACD;;AAED,QAAIxR,KAAK,CAAC,CAAD,CAAL,CAASkH,MAAT,CAAgBgL,OAAhB,IAA2B,KAAKzS,OAAL,CAAa+W,WAA5C,EAAyD;AACvD,UAAInD,KAAK,GAAG,KAAKQ,SAAL,CAAe7T,KAAK,CAAC,CAAD,CAApB,EAAyBqR,GAAzB,CAAZ;;AACA,UAAIgC,KAAK,CAACH,OAAN,KAAkB,KAAKzT,OAAL,CAAagX,gBAAnC,EAAqD;AACnD,aAAKtD,WAAL,CAAiBnT,KAAjB,EAAwB,CAACqT,KAAK,CAACP,SAAP,CAAxB;;AACA;AACD,OAHD,MAGO;AACL9H,QAAAA,OAAO,CAAC0L,IAAR,CAAa,0CAAb;AACD;AACF;;AAED,SAAKtK,gBAAL,CACEpM,KADF,EAEEsT,QAAQ,IACN,KAAK7T,OAAL,CAAakX,iBAAb,CAA+BhW,OAA/B,CAAuC,gBAAvC,EAAyD0Q,GAAG,CAAC5O,MAA7D,CAHJ,EAIE4O,GAJF;AAMD;;AAEDiE,EAAAA,aAAa,CAACjE,GAAD,EAAMwD,QAAN,EAAgB7U,KAAhB,EAAuB;AAClC,QAAIqR,GAAG,CAAC6E,UAAJ,IAAkB,CAAtB,EAAyB;AACvBlL,MAAAA,OAAO,CAAC0L,IAAR,CACE,+EADF;AAGA;AACD;;AACDrF,IAAAA,GAAG,CAACuF,IAAJ,CAAS/B,QAAT;AACD,GAtnD2C,CAwnD5C;AACA;;;AACAnB,EAAAA,SAAS,CAAC1T,KAAD,EAAQoW,YAAR,EAAsBpR,CAAtB,EAAyB;AAChC,SAAK,IAAIzD,IAAT,IAAiBvB,KAAjB,EAAwB;AACtBuB,MAAAA,IAAI,CAACkB,MAAL,GAAc9D,QAAQ,CAAC6U,OAAvB;AACA,WAAKjP,IAAL,CAAU,SAAV,EAAqBhD,IAArB,EAA2B6U,YAA3B,EAAyCpR,CAAzC;AACA,WAAKT,IAAL,CAAU,UAAV,EAAsBhD,IAAtB;AACD;;AACD,QAAI,KAAK9B,OAAL,CAAa0B,cAAjB,EAAiC;AAC/B,WAAKoD,IAAL,CAAU,iBAAV,EAA6BvE,KAA7B,EAAoCoW,YAApC,EAAkDpR,CAAlD;AACA,WAAKT,IAAL,CAAU,kBAAV,EAA8BvE,KAA9B;AACD;;AAED,QAAI,KAAKP,OAAL,CAAa+M,gBAAjB,EAAmC;AACjC,aAAO,KAAKC,YAAL,EAAP;AACD;AACF,GAxoD2C,CA0oD5C;AACA;;;AACAL,EAAAA,gBAAgB,CAACpM,KAAD,EAAQ6W,OAAR,EAAiBxF,GAAjB,EAAsB;AACpC,SAAK,IAAI9P,IAAT,IAAiBvB,KAAjB,EAAwB;AACtBuB,MAAAA,IAAI,CAACkB,MAAL,GAAc9D,QAAQ,CAACmY,KAAvB;AACA,WAAKvS,IAAL,CAAU,OAAV,EAAmBhD,IAAnB,EAAyBsV,OAAzB,EAAkCxF,GAAlC;AACA,WAAK9M,IAAL,CAAU,UAAV,EAAsBhD,IAAtB;AACD;;AACD,QAAI,KAAK9B,OAAL,CAAa0B,cAAjB,EAAiC;AAC/B,WAAKoD,IAAL,CAAU,eAAV,EAA2BvE,KAA3B,EAAkC6W,OAAlC,EAA2CxF,GAA3C;AACA,WAAK9M,IAAL,CAAU,kBAAV,EAA8BvE,KAA9B;AACD;;AAED,QAAI,KAAKP,OAAL,CAAa+M,gBAAjB,EAAmC;AACjC,aAAO,KAAKC,YAAL,EAAP;AACD;AACF;;AAEY,SAANT,MAAM,GAAG;AACd,WAAO,uCAAuCrL,OAAvC,CACL,OADK,EAEL,UAAUoW,CAAV,EAAa;AACX,UAAIC,CAAC,GAAI3N,IAAI,CAAC4N,MAAL,KAAgB,EAAjB,GAAuB,CAA/B;AAAA,UACEC,CAAC,GAAGH,CAAC,KAAK,GAAN,GAAYC,CAAZ,GAAiBA,CAAC,GAAG,GAAL,GAAY,GADlC;AAEA,aAAOE,CAAC,CAACC,QAAF,CAAW,EAAX,CAAP;AACD,KANI,CAAP;AAQD;;AArqD2C;AAuqD9CxY,QAAQ,CAACC,SAAT;AAEAD,QAAQ,CAACkB,OAAT,GAAmB,KAAnB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAlB,QAAQ,CAACc,OAAT,GAAmB,EAAnB,C,CAEA;;AACAd,QAAQ,CAAC8B,iBAAT,GAA6B,UAAUb,OAAV,EAAmB;AAC9C;AACA,MAAIA,OAAO,CAACoB,YAAR,CAAqB,IAArB,CAAJ,EAAgC;AAC9B,WAAOrC,QAAQ,CAACc,OAAT,CAAiB2X,QAAQ,CAACxX,OAAO,CAACoB,YAAR,CAAqB,IAArB,CAAD,CAAzB,CAAP;AACD,GAFD,MAEO;AACL,WAAO2F,SAAP;AACD;AACF,CAPD,C,CASA;;;AACAhI,QAAQ,CAAC2B,SAAT,GAAqB,EAArB,C,CAEA;;AACA3B,QAAQ,CAAC0Y,UAAT,GAAsB,UAAUzX,OAAV,EAAmB;AACvC,MAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC/BA,IAAAA,OAAO,GAAGK,QAAQ,CAACC,aAAT,CAAuBN,OAAvB,CAAV;AACD;;AACD,MAAI,CAACA,OAAO,IAAI,IAAX,GAAkBA,OAAO,CAACS,QAA1B,GAAqCsG,SAAtC,KAAoD,IAAxD,EAA8D;AAC5D,UAAM,IAAIvG,KAAJ,CACJ,gNADI,CAAN;AAGD;;AACD,SAAOR,OAAO,CAACS,QAAf;AACD,CAVD,C,CAYA;;;AACA1B,QAAQ,CAAC2Y,YAAT,GAAwB,IAAxB,C,CAEA;;AACA3Y,QAAQ,CAAC4Y,QAAT,GAAoB,YAAY;AAC9B,MAAIC,SAAJ;;AACA,MAAIvX,QAAQ,CAACyV,gBAAb,EAA+B;AAC7B8B,IAAAA,SAAS,GAAGvX,QAAQ,CAACyV,gBAAT,CAA0B,WAA1B,CAAZ;AACD,GAFD,MAEO;AACL8B,IAAAA,SAAS,GAAG,EAAZ,CADK,CAEL;;AACA,QAAIC,aAAa,GAAIzP,QAAD,IAClB,CAAC,MAAM;AACL,UAAIK,MAAM,GAAG,EAAb;;AACA,WAAK,IAAI7I,EAAT,IAAewI,QAAf,EAAyB;AACvB,YAAI,qBAAqBC,IAArB,CAA0BzI,EAAE,CAACoE,SAA7B,CAAJ,EAA6C;AAC3CyE,UAAAA,MAAM,CAAC9H,IAAP,CAAYiX,SAAS,CAACjX,IAAV,CAAef,EAAf,CAAZ;AACD,SAFD,MAEO;AACL6I,UAAAA,MAAM,CAAC9H,IAAP,CAAYoG,SAAZ;AACD;AACF;;AACD,aAAO0B,MAAP;AACD,KAVD,GADF;;AAYAoP,IAAAA,aAAa,CAACxX,QAAQ,CAACiI,oBAAT,CAA8B,KAA9B,CAAD,CAAb;AACAuP,IAAAA,aAAa,CAACxX,QAAQ,CAACiI,oBAAT,CAA8B,MAA9B,CAAD,CAAb;AACD;;AAED,SAAO,CAAC,MAAM;AACZ,QAAIG,MAAM,GAAG,EAAb;;AACA,SAAK,IAAIhI,QAAT,IAAqBmX,SAArB,EAAgC;AAC9B;AACA,UAAI7Y,QAAQ,CAAC8B,iBAAT,CAA2BJ,QAA3B,MAAyC,KAA7C,EAAoD;AAClDgI,QAAAA,MAAM,CAAC9H,IAAP,CAAY,IAAI5B,QAAJ,CAAa0B,QAAb,CAAZ;AACD,OAFD,MAEO;AACLgI,QAAAA,MAAM,CAAC9H,IAAP,CAAYoG,SAAZ;AACD;AACF;;AACD,WAAO0B,MAAP;AACD,GAXM,GAAP;AAYD,CAnCD,C,CAqCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA1J,QAAQ,CAAC+Y,eAAT,GAA2B,CACzB;AACA,gDAFyB,CAA3B,C,CAKA;;AACA/Y,QAAQ,CAACkC,kBAAT,GAA8B,YAAY;AACxC,MAAI8W,cAAc,GAAG,IAArB;;AAEA,MACElT,MAAM,CAACmT,IAAP,IACAnT,MAAM,CAAC8J,UADP,IAEA9J,MAAM,CAACoT,QAFP,IAGApT,MAAM,CAACqT,IAHP,IAIArT,MAAM,CAACqQ,QAJP,IAKA7U,QAAQ,CAACC,aANX,EAOE;AACA,QAAI,EAAE,eAAeD,QAAQ,CAACqD,aAAT,CAAuB,GAAvB,CAAjB,CAAJ,EAAmD;AACjDqU,MAAAA,cAAc,GAAG,KAAjB;AACD,KAFD,MAEO;AACL,UAAIhZ,QAAQ,CAACoZ,mBAAT,KAAiCpR,SAArC,EAAgD;AAC9C;AACA;AACAhI,QAAAA,QAAQ,CAAC+Y,eAAT,GAA2B/Y,QAAQ,CAACoZ,mBAApC;AACD,OALI,CAML;;;AACA,WAAK,IAAIC,KAAT,IAAkBrZ,QAAQ,CAAC+Y,eAA3B,EAA4C;AAC1C,YAAIM,KAAK,CAAC/P,IAAN,CAAWgQ,SAAS,CAACC,SAArB,CAAJ,EAAqC;AACnCP,UAAAA,cAAc,GAAG,KAAjB;AACA;AACD;AACF;AACF;AACF,GAxBD,MAwBO;AACLA,IAAAA,cAAc,GAAG,KAAjB;AACD;;AAED,SAAOA,cAAP;AACD,CAhCD;;AAkCAhZ,QAAQ,CAACyP,aAAT,GAAyB,UAAU+J,OAAV,EAAmB;AAC1C;AACA;AACA,MAAIC,UAAU,GAAGC,IAAI,CAACF,OAAO,CAACG,KAAR,CAAc,GAAd,EAAmB,CAAnB,CAAD,CAArB,CAH0C,CAK1C;;AACA,MAAIC,UAAU,GAAGJ,OAAO,CAACG,KAAR,CAAc,GAAd,EAAmB,CAAnB,EAAsBA,KAAtB,CAA4B,GAA5B,EAAiC,CAAjC,EAAoCA,KAApC,CAA0C,GAA1C,EAA+C,CAA/C,CAAjB,CAN0C,CAQ1C;;AACA,MAAIE,EAAE,GAAG,IAAIC,WAAJ,CAAgBL,UAAU,CAAC5U,MAA3B,CAAT;AACA,MAAIkV,EAAE,GAAG,IAAIC,UAAJ,CAAeH,EAAf,CAAT;;AACA,OACE,IAAIrT,CAAC,GAAG,CAAR,EAAWyN,GAAG,GAAGwF,UAAU,CAAC5U,MAA5B,EAAoCoV,GAAG,GAAG,KAAKhG,GADjD,EAEEgG,GAAG,GAAGzT,CAAC,IAAIyN,GAAR,GAAczN,CAAC,IAAIyN,GAFxB,EAGEgG,GAAG,GAAGzT,CAAC,EAAJ,GAASA,CAAC,EAHf,EAIE;AACAuT,IAAAA,EAAE,CAACvT,CAAD,CAAF,GAAQiT,UAAU,CAACS,UAAX,CAAsB1T,CAAtB,CAAR;AACD,GAjByC,CAmB1C;;;AACA,SAAO,IAAI2S,IAAJ,CAAS,CAACU,EAAD,CAAT,EAAe;AAAE7L,IAAAA,IAAI,EAAE4L;AAAR,GAAf,CAAP;AACD,CArBD,C,CAuBA;;;AACA,MAAMjL,OAAO,GAAG,CAACwL,IAAD,EAAOC,YAAP,KACdD,IAAI,CAAC1W,MAAL,CAAa+H,IAAD,IAAUA,IAAI,KAAK4O,YAA/B,EAA6CzW,GAA7C,CAAkD6H,IAAD,IAAUA,IAA3D,CADF,C,CAGA;;;AACA,MAAMiN,QAAQ,GAAI4B,GAAD,IACfA,GAAG,CAACrY,OAAJ,CAAY,YAAZ,EAA2BiM,KAAD,IAAWA,KAAK,CAACqM,MAAN,CAAa,CAAb,EAAgBvX,WAAhB,EAArC,CADF,C,CAGA;;;AACA/C,QAAQ,CAAC2E,aAAT,GAAyB,UAAU4V,MAAV,EAAkB;AACzC,MAAIC,GAAG,GAAGlZ,QAAQ,CAACqD,aAAT,CAAuB,KAAvB,CAAV;AACA6V,EAAAA,GAAG,CAACC,SAAJ,GAAgBF,MAAhB;AACA,SAAOC,GAAG,CAACE,UAAJ,CAAe,CAAf,CAAP;AACD,CAJD,C,CAMA;;;AACA1a,QAAQ,CAAC2H,aAAT,GAAyB,UAAU1G,OAAV,EAAmB0Z,SAAnB,EAA8B;AACrD,MAAI1Z,OAAO,KAAK0Z,SAAhB,EAA2B;AACzB,WAAO,IAAP;AACD,GAHoD,CAGnD;;;AACF,SAAQ1Z,OAAO,GAAGA,OAAO,CAACgC,UAA1B,EAAuC;AACrC,QAAIhC,OAAO,KAAK0Z,SAAhB,EAA2B;AACzB,aAAO,IAAP;AACD;AACF;;AACD,SAAO,KAAP;AACD,CAVD;;AAYA3a,QAAQ,CAACoD,UAAT,GAAsB,UAAUvC,EAAV,EAAcgC,IAAd,EAAoB;AACxC,MAAI5B,OAAJ;;AACA,MAAI,OAAOJ,EAAP,KAAc,QAAlB,EAA4B;AAC1BI,IAAAA,OAAO,GAAGK,QAAQ,CAACC,aAAT,CAAuBV,EAAvB,CAAV;AACD,GAFD,MAEO,IAAIA,EAAE,CAACW,QAAH,IAAe,IAAnB,EAAyB;AAC9BP,IAAAA,OAAO,GAAGJ,EAAV;AACD;;AACD,MAAII,OAAO,IAAI,IAAf,EAAqB;AACnB,UAAM,IAAIQ,KAAJ,CACH,aAAYoB,IAAK,4EADd,CAAN;AAGD;;AACD,SAAO5B,OAAP;AACD,CAbD;;AAeAjB,QAAQ,CAACsD,WAAT,GAAuB,UAAUsX,GAAV,EAAe/X,IAAf,EAAqB;AAC1C,MAAIhC,EAAJ,EAAQwI,QAAR;;AACA,MAAIuR,GAAG,YAAYrE,KAAnB,EAA0B;AACxBlN,IAAAA,QAAQ,GAAG,EAAX;;AACA,QAAI;AACF,WAAKxI,EAAL,IAAW+Z,GAAX,EAAgB;AACdvR,QAAAA,QAAQ,CAACzH,IAAT,CAAc,KAAKwB,UAAL,CAAgBvC,EAAhB,EAAoBgC,IAApB,CAAd;AACD;AACF,KAJD,CAIE,OAAOwD,CAAP,EAAU;AACVgD,MAAAA,QAAQ,GAAG,IAAX;AACD;AACF,GATD,MASO,IAAI,OAAOuR,GAAP,KAAe,QAAnB,EAA6B;AAClCvR,IAAAA,QAAQ,GAAG,EAAX;;AACA,SAAKxI,EAAL,IAAWS,QAAQ,CAACyV,gBAAT,CAA0B6D,GAA1B,CAAX,EAA2C;AACzCvR,MAAAA,QAAQ,CAACzH,IAAT,CAAcf,EAAd;AACD;AACF,GALM,MAKA,IAAI+Z,GAAG,CAACpZ,QAAJ,IAAgB,IAApB,EAA0B;AAC/B6H,IAAAA,QAAQ,GAAG,CAACuR,GAAD,CAAX;AACD;;AAED,MAAIvR,QAAQ,IAAI,IAAZ,IAAoB,CAACA,QAAQ,CAACxE,MAAlC,EAA0C;AACxC,UAAM,IAAIpD,KAAJ,CACH,aAAYoB,IAAK,6FADd,CAAN;AAGD;;AAED,SAAOwG,QAAP;AACD,CA3BD,C,CA6BA;AACA;AACA;AACA;;;AACArJ,QAAQ,CAAC6a,OAAT,GAAmB,UAAUC,QAAV,EAAoBpX,QAApB,EAA8BqX,QAA9B,EAAwC;AACzD,MAAIjV,MAAM,CAAC+U,OAAP,CAAeC,QAAf,CAAJ,EAA8B;AAC5B,WAAOpX,QAAQ,EAAf;AACD,GAFD,MAEO,IAAIqX,QAAQ,IAAI,IAAhB,EAAsB;AAC3B,WAAOA,QAAQ,EAAf;AACD;AACF,CAND,C,CAQA;AACA;AACA;;;AACA/a,QAAQ,CAACiN,WAAT,GAAuB,UAAUrK,IAAV,EAAgBN,aAAhB,EAA+B;AACpD,MAAI,CAACA,aAAL,EAAoB;AAClB,WAAO,IAAP;AACD,GAHmD,CAGlD;;;AACFA,EAAAA,aAAa,GAAGA,aAAa,CAACqX,KAAd,CAAoB,GAApB,CAAhB;AAEA,MAAIqB,QAAQ,GAAGpY,IAAI,CAACoL,IAApB;AACA,MAAIiN,YAAY,GAAGD,QAAQ,CAAChZ,OAAT,CAAiB,OAAjB,EAA0B,EAA1B,CAAnB;;AAEA,OAAK,IAAIkZ,SAAT,IAAsB5Y,aAAtB,EAAqC;AACnC4Y,IAAAA,SAAS,GAAGA,SAAS,CAACC,IAAV,EAAZ;;AACA,QAAID,SAAS,CAACZ,MAAV,CAAiB,CAAjB,MAAwB,GAA5B,EAAiC;AAC/B,UACE1X,IAAI,CAACC,IAAL,CACGqU,WADH,GAEGhP,OAFH,CAGIgT,SAAS,CAAChE,WAAV,EAHJ,EAIItU,IAAI,CAACC,IAAL,CAAUgC,MAAV,GAAmBqW,SAAS,CAACrW,MAJjC,MAKQ,CAAC,CANX,EAOE;AACA,eAAO,IAAP;AACD;AACF,KAXD,MAWO,IAAI,QAAQyE,IAAR,CAAa4R,SAAb,CAAJ,EAA6B;AAClC;AACA,UAAID,YAAY,KAAKC,SAAS,CAAClZ,OAAV,CAAkB,OAAlB,EAA2B,EAA3B,CAArB,EAAqD;AACnD,eAAO,IAAP;AACD;AACF,KALM,MAKA;AACL,UAAIgZ,QAAQ,KAAKE,SAAjB,EAA4B;AAC1B,eAAO,IAAP;AACD;AACF;AACF;;AAED,SAAO,KAAP;AACD,CAnCD,C,CAqCA;;;AACA,IAAI,OAAOE,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,KAAK,IAAhD,EAAsD;AACpDA,EAAAA,MAAM,CAACC,EAAP,CAAU3Z,QAAV,GAAqB,UAAUZ,OAAV,EAAmB;AACtC,WAAO,KAAKwa,IAAL,CAAU,YAAY;AAC3B,aAAO,IAAItb,QAAJ,CAAa,IAAb,EAAmBc,OAAnB,CAAP;AACD,KAFM,CAAP;AAGD,GAJD;AAKD,C,CAED;;;AACAd,QAAQ,CAACoE,KAAT,GAAiB,OAAjB;AAEApE,QAAQ,CAACgE,MAAT,GAAkB,QAAlB,C,CACA;AACA;;AACAhE,QAAQ,CAACub,QAAT,GAAoBvb,QAAQ,CAACgE,MAA7B;AAEAhE,QAAQ,CAACkE,SAAT,GAAqB,WAArB;AACAlE,QAAQ,CAACwb,UAAT,GAAsBxb,QAAQ,CAACkE,SAA/B,C,CAA0C;;AAE1ClE,QAAQ,CAAC6S,QAAT,GAAoB,UAApB;AACA7S,QAAQ,CAACmY,KAAT,GAAiB,OAAjB;AACAnY,QAAQ,CAAC6U,OAAT,GAAmB,SAAnB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA,IAAI4G,oBAAoB,GAAG,UAAUlL,GAAV,EAAe;AACxC,MAAImL,EAAE,GAAGnL,GAAG,CAACoL,YAAb;AACA,MAAIC,EAAE,GAAGrL,GAAG,CAACsL,aAAb;AACA,MAAI5M,MAAM,GAAG3N,QAAQ,CAACqD,aAAT,CAAuB,QAAvB,CAAb;AACAsK,EAAAA,MAAM,CAACzJ,KAAP,GAAe,CAAf;AACAyJ,EAAAA,MAAM,CAAC1J,MAAP,GAAgBqW,EAAhB;AACA,MAAI3K,GAAG,GAAGhC,MAAM,CAACiC,UAAP,CAAkB,IAAlB,CAAV;AACAD,EAAAA,GAAG,CAAC6K,SAAJ,CAAcvL,GAAd,EAAmB,CAAnB,EAAsB,CAAtB;AACA,MAAI;AAAE6D,IAAAA;AAAF,MAAWnD,GAAG,CAAC8K,YAAJ,CAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,EAA0BH,EAA1B,CAAf,CARwC,CAUxC;;AACA,MAAII,EAAE,GAAG,CAAT;AACA,MAAIC,EAAE,GAAGL,EAAT;AACA,MAAIM,EAAE,GAAGN,EAAT;;AACA,SAAOM,EAAE,GAAGF,EAAZ,EAAgB;AACd,QAAIG,KAAK,GAAG/H,IAAI,CAAC,CAAC8H,EAAE,GAAG,CAAN,IAAW,CAAX,GAAe,CAAhB,CAAhB;;AAEA,QAAIC,KAAK,KAAK,CAAd,EAAiB;AACfF,MAAAA,EAAE,GAAGC,EAAL;AACD,KAFD,MAEO;AACLF,MAAAA,EAAE,GAAGE,EAAL;AACD;;AAEDA,IAAAA,EAAE,GAAID,EAAE,GAAGD,EAAN,IAAa,CAAlB;AACD;;AACD,MAAII,KAAK,GAAGF,EAAE,GAAGN,EAAjB;;AAEA,MAAIQ,KAAK,KAAK,CAAd,EAAiB;AACf,WAAO,CAAP;AACD,GAFD,MAEO;AACL,WAAOA,KAAP;AACD;AACF,CAhCD,C,CAkCA;AACA;;;AACA,IAAI3K,eAAe,GAAG,UAAUR,GAAV,EAAeV,GAAf,EAAoB8L,EAApB,EAAwBL,EAAxB,EAA4BM,EAA5B,EAAgCC,EAAhC,EAAoCC,EAApC,EAAwCC,EAAxC,EAA4CC,EAA5C,EAAgDC,EAAhD,EAAoD;AACxE,MAAIC,eAAe,GAAGnB,oBAAoB,CAAClL,GAAD,CAA1C;AACA,SAAOU,GAAG,CAAC6K,SAAJ,CAAcvL,GAAd,EAAmB8L,EAAnB,EAAuBL,EAAvB,EAA2BM,EAA3B,EAA+BC,EAA/B,EAAmCC,EAAnC,EAAuCC,EAAvC,EAA2CC,EAA3C,EAA+CC,EAAE,GAAGC,eAApD,CAAP;AACD,CAHD,C,CAKA;AACA;AACA;;;AACA,MAAMtN,WAAN,CAAkB;AACA,SAATrP,SAAS,GAAG;AACjB,SAAK4c,OAAL,GACE,mEADF;AAED;;AAEc,SAARC,QAAQ,CAAChG,KAAD,EAAQ;AACrB,QAAIiG,MAAM,GAAG,EAAb;AACA,QAAIC,IAAI,GAAGhV,SAAX;AACA,QAAIiV,IAAI,GAAGjV,SAAX;AACA,QAAIkV,IAAI,GAAG,EAAX;AACA,QAAIC,IAAI,GAAGnV,SAAX;AACA,QAAIoV,IAAI,GAAGpV,SAAX;AACA,QAAIqV,IAAI,GAAGrV,SAAX;AACA,QAAIsV,IAAI,GAAG,EAAX;AACA,QAAI9W,CAAC,GAAG,CAAR;;AACA,WAAO,IAAP,EAAa;AACXwW,MAAAA,IAAI,GAAGlG,KAAK,CAACtQ,CAAC,EAAF,CAAZ;AACAyW,MAAAA,IAAI,GAAGnG,KAAK,CAACtQ,CAAC,EAAF,CAAZ;AACA0W,MAAAA,IAAI,GAAGpG,KAAK,CAACtQ,CAAC,EAAF,CAAZ;AACA2W,MAAAA,IAAI,GAAGH,IAAI,IAAI,CAAf;AACAI,MAAAA,IAAI,GAAI,CAACJ,IAAI,GAAG,CAAR,KAAc,CAAf,GAAqBC,IAAI,IAAI,CAApC;AACAI,MAAAA,IAAI,GAAI,CAACJ,IAAI,GAAG,EAAR,KAAe,CAAhB,GAAsBC,IAAI,IAAI,CAArC;AACAI,MAAAA,IAAI,GAAGJ,IAAI,GAAG,EAAd;;AACA,UAAIK,KAAK,CAACN,IAAD,CAAT,EAAiB;AACfI,QAAAA,IAAI,GAAGC,IAAI,GAAG,EAAd;AACD,OAFD,MAEO,IAAIC,KAAK,CAACL,IAAD,CAAT,EAAiB;AACtBI,QAAAA,IAAI,GAAG,EAAP;AACD;;AACDP,MAAAA,MAAM,GACJA,MAAM,GACN,KAAKF,OAAL,CAAavC,MAAb,CAAoB6C,IAApB,CADA,GAEA,KAAKN,OAAL,CAAavC,MAAb,CAAoB8C,IAApB,CAFA,GAGA,KAAKP,OAAL,CAAavC,MAAb,CAAoB+C,IAApB,CAHA,GAIA,KAAKR,OAAL,CAAavC,MAAb,CAAoBgD,IAApB,CALF;AAMAN,MAAAA,IAAI,GAAGC,IAAI,GAAGC,IAAI,GAAG,EAArB;AACAC,MAAAA,IAAI,GAAGC,IAAI,GAAGC,IAAI,GAAGC,IAAI,GAAG,EAA5B;;AACA,UAAI,EAAE9W,CAAC,GAAGsQ,KAAK,CAACjS,MAAZ,CAAJ,EAAyB;AACvB;AACD;AACF;;AACD,WAAOkY,MAAP;AACD;;AAEa,SAAPxN,OAAO,CAACiO,cAAD,EAAiBC,iBAAjB,EAAoC;AAChD,QAAI,CAACD,cAAc,CAACvP,KAAf,CAAqB,yBAArB,CAAL,EAAsD;AACpD,aAAOwP,iBAAP;AACD;;AACD,QAAIC,QAAQ,GAAG,KAAKC,QAAL,CACbH,cAAc,CAACxb,OAAf,CAAuB,yBAAvB,EAAkD,EAAlD,CADa,CAAf;AAGA,QAAI4b,QAAQ,GAAG,KAAKC,cAAL,CAAoBH,QAApB,CAAf;AACA,QAAII,KAAK,GAAG,KAAKC,gBAAL,CAAsBN,iBAAtB,EAAyCG,QAAzC,CAAZ;AACA,WAAQ,0BAAyB,KAAKd,QAAL,CAAcgB,KAAd,CAAqB,EAAtD;AACD;;AAEsB,SAAhBC,gBAAgB,CAACN,iBAAD,EAAoBG,QAApB,EAA8B;AACnD,QAAII,SAAS,GAAG,KAAKC,YAAL,CAAkBL,QAAlB,CAAhB;AACA,QAAIM,aAAa,GAAG,KAAKC,UAAL,CAAgBV,iBAAhB,EAAmCO,SAAnC,CAApB;AACA,QAAII,OAAO,GAAG,IAAIpE,UAAJ,CAAekE,aAAf,CAAd;AACA,WAAOE,OAAP;AACD;;AAEkB,SAAZH,YAAY,CAACL,QAAD,EAAW;AAC5B,QAAIS,GAAG,GAAGrW,SAAV;AACA,QAAIuD,CAAC,GAAG,CAAR;;AACA,WAAOA,CAAC,GAAGqS,QAAQ,CAAC/Y,MAApB,EAA4B;AAC1BwZ,MAAAA,GAAG,GAAGT,QAAQ,CAACrS,CAAD,CAAd;;AACA,UAAK8S,GAAG,CAAC,CAAD,CAAH,KAAW,GAAZ,GAAoBA,GAAG,CAAC,CAAD,CAAH,KAAW,GAAnC,EAAyC;AACvC,eAAOA,GAAP;AACD;;AACD9S,MAAAA,CAAC;AACF;;AACD,WAAO,EAAP;AACD;;AAEgB,SAAV4S,UAAU,CAACV,iBAAD,EAAoBO,SAApB,EAA+B;AAC9C,QAAIM,SAAS,GAAGb,iBAAiB,CAACzb,OAAlB,CAA0B,yBAA1B,EAAqD,EAArD,CAAhB;AACA,QAAIuc,GAAG,GAAG,KAAKZ,QAAL,CAAcW,SAAd,CAAV;AACA,QAAIE,aAAa,GAAGD,GAAG,CAACrW,OAAJ,CAAY,GAAZ,EAAiB,CAAjB,CAApB;AACA,QAAIuW,GAAG,GAAGF,GAAG,CAAC1P,KAAJ,CAAU,CAAV,EAAa2P,aAAb,CAAV;AACA,QAAIE,GAAG,GAAGH,GAAG,CAAC1P,KAAJ,CAAU2P,aAAV,CAAV;AACA,QAAIG,KAAK,GAAGF,GAAZ;AACAE,IAAAA,KAAK,GAAGA,KAAK,CAACC,MAAN,CAAaZ,SAAb,CAAR;AACAW,IAAAA,KAAK,GAAGA,KAAK,CAACC,MAAN,CAAaF,GAAb,CAAR;AACA,WAAOC,KAAP;AACD;;AAEoB,SAAdd,cAAc,CAACgB,aAAD,EAAgB;AACnC,QAAIC,IAAI,GAAG,CAAX;AACA,QAAIlB,QAAQ,GAAG,EAAf;;AACA,WAAO,IAAP,EAAa;AACX,UAAI/Y,MAAJ;;AACA,UAAKga,aAAa,CAACC,IAAD,CAAb,KAAwB,GAAzB,GAAiCD,aAAa,CAACC,IAAI,GAAG,CAAR,CAAb,KAA4B,GAAjE,EAAuE;AACrE;AACD;;AACD,UAAKD,aAAa,CAACC,IAAD,CAAb,KAAwB,GAAzB,GAAiCD,aAAa,CAACC,IAAI,GAAG,CAAR,CAAb,KAA4B,GAAjE,EAAuE;AACrEA,QAAAA,IAAI,IAAI,CAAR;AACD,OAFD,MAEO;AACLja,QAAAA,MAAM,GAAGga,aAAa,CAACC,IAAI,GAAG,CAAR,CAAb,GAA0B,GAA1B,GAAgCD,aAAa,CAACC,IAAI,GAAG,CAAR,CAAtD;AACA,YAAIC,QAAQ,GAAGD,IAAI,GAAGja,MAAP,GAAgB,CAA/B;AACA,YAAIwZ,GAAG,GAAGQ,aAAa,CAAChQ,KAAd,CAAoBiQ,IAApB,EAA0BC,QAA1B,CAAV;AACAnB,QAAAA,QAAQ,CAAChc,IAAT,CAAcyc,GAAd;AACAS,QAAAA,IAAI,GAAGC,QAAP;AACD;;AACD,UAAID,IAAI,GAAGD,aAAa,CAACha,MAAzB,EAAiC;AAC/B;AACD;AACF;;AACD,WAAO+Y,QAAP;AACD;;AAEc,SAARD,QAAQ,CAAC7G,KAAD,EAAQ;AACrB,QAAIiG,MAAM,GAAG,EAAb;AACA,QAAIC,IAAI,GAAGhV,SAAX;AACA,QAAIiV,IAAI,GAAGjV,SAAX;AACA,QAAIkV,IAAI,GAAG,EAAX;AACA,QAAIC,IAAI,GAAGnV,SAAX;AACA,QAAIoV,IAAI,GAAGpV,SAAX;AACA,QAAIqV,IAAI,GAAGrV,SAAX;AACA,QAAIsV,IAAI,GAAG,EAAX;AACA,QAAI9W,CAAC,GAAG,CAAR;AACA,QAAI+X,GAAG,GAAG,EAAV,CAVqB,CAWrB;;AACA,QAAIS,UAAU,GAAG,qBAAjB;;AACA,QAAIA,UAAU,CAACC,IAAX,CAAgBnI,KAAhB,CAAJ,EAA4B;AAC1BzK,MAAAA,OAAO,CAAC0L,IAAR,CACE,kJADF;AAGD;;AACDjB,IAAAA,KAAK,GAAGA,KAAK,CAAC9U,OAAN,CAAc,qBAAd,EAAqC,EAArC,CAAR;;AACA,WAAO,IAAP,EAAa;AACXmb,MAAAA,IAAI,GAAG,KAAKN,OAAL,CAAa3U,OAAb,CAAqB4O,KAAK,CAACwD,MAAN,CAAa9T,CAAC,EAAd,CAArB,CAAP;AACA4W,MAAAA,IAAI,GAAG,KAAKP,OAAL,CAAa3U,OAAb,CAAqB4O,KAAK,CAACwD,MAAN,CAAa9T,CAAC,EAAd,CAArB,CAAP;AACA6W,MAAAA,IAAI,GAAG,KAAKR,OAAL,CAAa3U,OAAb,CAAqB4O,KAAK,CAACwD,MAAN,CAAa9T,CAAC,EAAd,CAArB,CAAP;AACA8W,MAAAA,IAAI,GAAG,KAAKT,OAAL,CAAa3U,OAAb,CAAqB4O,KAAK,CAACwD,MAAN,CAAa9T,CAAC,EAAd,CAArB,CAAP;AACAwW,MAAAA,IAAI,GAAIG,IAAI,IAAI,CAAT,GAAeC,IAAI,IAAI,CAA9B;AACAH,MAAAA,IAAI,GAAI,CAACG,IAAI,GAAG,EAAR,KAAe,CAAhB,GAAsBC,IAAI,IAAI,CAArC;AACAH,MAAAA,IAAI,GAAI,CAACG,IAAI,GAAG,CAAR,KAAc,CAAf,GAAoBC,IAA3B;AACAiB,MAAAA,GAAG,CAAC3c,IAAJ,CAASob,IAAT;;AACA,UAAIK,IAAI,KAAK,EAAb,EAAiB;AACfkB,QAAAA,GAAG,CAAC3c,IAAJ,CAASqb,IAAT;AACD;;AACD,UAAIK,IAAI,KAAK,EAAb,EAAiB;AACfiB,QAAAA,GAAG,CAAC3c,IAAJ,CAASsb,IAAT;AACD;;AACDF,MAAAA,IAAI,GAAGC,IAAI,GAAGC,IAAI,GAAG,EAArB;AACAC,MAAAA,IAAI,GAAGC,IAAI,GAAGC,IAAI,GAAGC,IAAI,GAAG,EAA5B;;AACA,UAAI,EAAE9W,CAAC,GAAGsQ,KAAK,CAACjS,MAAZ,CAAJ,EAAyB;AACvB;AACD;AACF;;AACD,WAAO0Z,GAAP;AACD;;AAzJe;;AA2JlBjP,WAAW,CAACrP,SAAZ;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA,IAAIif,aAAa,GAAG,UAAUC,GAAV,EAAe9D,EAAf,EAAmB;AACrC,MAAIvO,IAAI,GAAG,KAAX;AACA,MAAIxH,GAAG,GAAG,IAAV;AACA,MAAI8Z,GAAG,GAAGD,GAAG,CAAC7d,QAAd;AACA,MAAI+d,IAAI,GAAGD,GAAG,CAACE,eAAf;AACA,MAAIpV,GAAG,GAAGkV,GAAG,CAAC1Z,gBAAJ,GAAuB,kBAAvB,GAA4C,aAAtD;AACA,MAAI6Z,GAAG,GAAGH,GAAG,CAAC1Z,gBAAJ,GAAuB,qBAAvB,GAA+C,aAAzD;AACA,MAAI8Z,GAAG,GAAGJ,GAAG,CAAC1Z,gBAAJ,GAAuB,EAAvB,GAA4B,IAAtC;;AACA,MAAInC,IAAI,GAAG,UAAU8C,CAAV,EAAa;AACtB,QAAIA,CAAC,CAAC2H,IAAF,KAAW,kBAAX,IAAiCoR,GAAG,CAAC7H,UAAJ,KAAmB,UAAxD,EAAoE;AAClE;AACD;;AACD,KAAClR,CAAC,CAAC2H,IAAF,KAAW,MAAX,GAAoBmR,GAApB,GAA0BC,GAA3B,EAAgCG,GAAhC,EAAqCC,GAAG,GAAGnZ,CAAC,CAAC2H,IAA7C,EAAmDzK,IAAnD,EAAyD,KAAzD;;AACA,QAAI,CAACuJ,IAAD,KAAUA,IAAI,GAAG,IAAjB,CAAJ,EAA4B;AAC1B,aAAOuO,EAAE,CAAClZ,IAAH,CAAQgd,GAAR,EAAa9Y,CAAC,CAAC2H,IAAF,IAAU3H,CAAvB,CAAP;AACD;AACF,GARD;;AAUA,MAAIoZ,IAAI,GAAG,YAAY;AACrB,QAAI;AACFJ,MAAAA,IAAI,CAACK,QAAL,CAAc,MAAd;AACD,KAFD,CAEE,OAAOrZ,CAAP,EAAU;AACVF,MAAAA,UAAU,CAACsZ,IAAD,EAAO,EAAP,CAAV;AACA;AACD;;AACD,WAAOlc,IAAI,CAAC,MAAD,CAAX;AACD,GARD;;AAUA,MAAI6b,GAAG,CAAC7H,UAAJ,KAAmB,UAAvB,EAAmC;AACjC,QAAI6H,GAAG,CAACO,iBAAJ,IAAyBN,IAAI,CAACK,QAAlC,EAA4C;AAC1C,UAAI;AACFpa,QAAAA,GAAG,GAAG,CAAC6Z,GAAG,CAACS,YAAX;AACD,OAFD,CAEE,OAAO1Y,KAAP,EAAc,CAAE;;AAClB,UAAI5B,GAAJ,EAAS;AACPma,QAAAA,IAAI;AACL;AACF;;AACDL,IAAAA,GAAG,CAAClV,GAAD,CAAH,CAASsV,GAAG,GAAG,kBAAf,EAAmCjc,IAAnC,EAAyC,KAAzC;AACA6b,IAAAA,GAAG,CAAClV,GAAD,CAAH,CAASsV,GAAG,GAAG,kBAAf,EAAmCjc,IAAnC,EAAyC,KAAzC;AACA,WAAO4b,GAAG,CAACjV,GAAD,CAAH,CAASsV,GAAG,GAAG,MAAf,EAAuBjc,IAAvB,EAA6B,KAA7B,CAAP;AACD;AACF,CAzCD,C,CA2CA;;;AACAvD,QAAQ,CAAC6f,qBAAT,GAAiC,YAAY;AAC3C,MAAI7f,QAAQ,CAAC2Y,YAAb,EAA2B;AACzB,WAAO3Y,QAAQ,CAAC4Y,QAAT,EAAP;AACD;AACF,CAJD;;AAKAsG,aAAa,CAACpZ,MAAD,EAAS9F,QAAQ,CAAC6f,qBAAlB,CAAb;;AAEA,SAASxU,SAAT,CAAmBiL,KAAnB,EAA0BwJ,SAA1B,EAAqC;AACnC,SAAO,OAAOxJ,KAAP,KAAiB,WAAjB,IAAgCA,KAAK,KAAK,IAA1C,GACHwJ,SAAS,CAACxJ,KAAD,CADN,GAEHtO,SAFJ;AAGD;;AACD,SAASoE,eAAT,CAAyB2T,GAAzB,EAA8BC,UAA9B,EAA0CF,SAA1C,EAAqD;AACnD,MACE,OAAOC,GAAP,KAAe,WAAf,IACAA,GAAG,KAAK,IADR,IAEA,OAAOA,GAAG,CAACC,UAAD,CAAV,KAA2B,UAH7B,EAIE;AACA,WAAOF,SAAS,CAACC,GAAD,EAAMC,UAAN,CAAhB;AACD,GAND,MAMO;AACL,WAAOhY,SAAP;AACD;AACF;;AAED,SAAShI,QAAT","sourcesContent":["import Emitter from \"./emitter.js\";\nimport defaultOptions from \"./options.js\";\n\nexport default class Dropzone extends Emitter {\n  static initClass() {\n    // Exposing the emitter class, mainly for tests\n    this.prototype.Emitter = Emitter;\n\n    /*\n     This is a list of all available events you can register on a dropzone object.\n\n     You can register an event handler like this:\n\n     dropzone.on(\"dragEnter\", function() { });\n\n     */\n    this.prototype.events = [\n      \"drop\",\n      \"dragstart\",\n      \"dragend\",\n      \"dragenter\",\n      \"dragover\",\n      \"dragleave\",\n      \"addedfile\",\n      \"addedfiles\",\n      \"removedfile\",\n      \"thumbnail\",\n      \"error\",\n      \"errormultiple\",\n      \"processing\",\n      \"processingmultiple\",\n      \"uploadprogress\",\n      \"totaluploadprogress\",\n      \"sending\",\n      \"sendingmultiple\",\n      \"success\",\n      \"successmultiple\",\n      \"canceled\",\n      \"canceledmultiple\",\n      \"complete\",\n      \"completemultiple\",\n      \"reset\",\n      \"maxfilesexceeded\",\n      \"maxfilesreached\",\n      \"queuecomplete\",\n    ];\n\n    this.prototype._thumbnailQueue = [];\n    this.prototype._processingThumbnail = false;\n  }\n\n  // global utility\n  static extend(target, ...objects) {\n    for (let object of objects) {\n      for (let key in object) {\n        let val = object[key];\n        target[key] = val;\n      }\n    }\n    return target;\n  }\n\n  constructor(el, options) {\n    super();\n    let fallback, left;\n    this.element = el;\n    // For backwards compatibility since the version was in the prototype previously\n    this.version = Dropzone.version;\n\n    this.clickableElements = [];\n    this.listeners = [];\n    this.files = []; // All files\n\n    if (typeof this.element === \"string\") {\n      this.element = document.querySelector(this.element);\n    }\n\n    // Not checking if instance of HTMLElement or Element since IE9 is extremely weird.\n    if (!this.element || this.element.nodeType == null) {\n      throw new Error(\"Invalid dropzone element.\");\n    }\n\n    if (this.element.dropzone) {\n      throw new Error(\"Dropzone already attached.\");\n    }\n\n    // Now add this dropzone to the instances.\n    Dropzone.instances.push(this);\n\n    // Put the dropzone inside the element itself.\n    this.element.dropzone = this;\n\n    let elementOptions =\n      (left = Dropzone.optionsForElement(this.element)) != null ? left : {};\n\n    this.options = Dropzone.extend(\n      {},\n      defaultOptions,\n      elementOptions,\n      options != null ? options : {}\n    );\n\n    this.options.previewTemplate = this.options.previewTemplate.replace(\n      /\\n*/g,\n      \"\"\n    );\n\n    // If the browser failed, just call the fallback and leave\n    if (this.options.forceFallback || !Dropzone.isBrowserSupported()) {\n      return this.options.fallback.call(this);\n    }\n\n    // @options.url = @element.getAttribute \"action\" unless @options.url?\n    if (this.options.url == null) {\n      this.options.url = this.element.getAttribute(\"action\");\n    }\n\n    if (!this.options.url) {\n      throw new Error(\"No URL provided.\");\n    }\n\n    if (this.options.acceptedFiles && this.options.acceptedMimeTypes) {\n      throw new Error(\n        \"You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.\"\n      );\n    }\n\n    if (this.options.uploadMultiple && this.options.chunking) {\n      throw new Error(\"You cannot set both: uploadMultiple and chunking.\");\n    }\n\n    // Backwards compatibility\n    if (this.options.acceptedMimeTypes) {\n      this.options.acceptedFiles = this.options.acceptedMimeTypes;\n      delete this.options.acceptedMimeTypes;\n    }\n\n    // Backwards compatibility\n    if (this.options.renameFilename != null) {\n      this.options.renameFile = (file) =>\n        this.options.renameFilename.call(this, file.name, file);\n    }\n\n    if (typeof this.options.method === \"string\") {\n      this.options.method = this.options.method.toUpperCase();\n    }\n\n    if ((fallback = this.getExistingFallback()) && fallback.parentNode) {\n      // Remove the fallback\n      fallback.parentNode.removeChild(fallback);\n    }\n\n    // Display previews in the previewsContainer element or the Dropzone element unless explicitly set to false\n    if (this.options.previewsContainer !== false) {\n      if (this.options.previewsContainer) {\n        this.previewsContainer = Dropzone.getElement(\n          this.options.previewsContainer,\n          \"previewsContainer\"\n        );\n      } else {\n        this.previewsContainer = this.element;\n      }\n    }\n\n    if (this.options.clickable) {\n      if (this.options.clickable === true) {\n        this.clickableElements = [this.element];\n      } else {\n        this.clickableElements = Dropzone.getElements(\n          this.options.clickable,\n          \"clickable\"\n        );\n      }\n    }\n\n    this.init();\n  }\n\n  // Returns all files that have been accepted\n  getAcceptedFiles() {\n    return this.files.filter((file) => file.accepted).map((file) => file);\n  }\n\n  // Returns all files that have been rejected\n  // Not sure when that's going to be useful, but added for completeness.\n  getRejectedFiles() {\n    return this.files.filter((file) => !file.accepted).map((file) => file);\n  }\n\n  getFilesWithStatus(status) {\n    return this.files\n      .filter((file) => file.status === status)\n      .map((file) => file);\n  }\n\n  // Returns all files that are in the queue\n  getQueuedFiles() {\n    return this.getFilesWithStatus(Dropzone.QUEUED);\n  }\n\n  getUploadingFiles() {\n    return this.getFilesWithStatus(Dropzone.UPLOADING);\n  }\n\n  getAddedFiles() {\n    return this.getFilesWithStatus(Dropzone.ADDED);\n  }\n\n  // Files that are either queued or uploading\n  getActiveFiles() {\n    return this.files\n      .filter(\n        (file) =>\n          file.status === Dropzone.UPLOADING || file.status === Dropzone.QUEUED\n      )\n      .map((file) => file);\n  }\n\n  // The function that gets called when Dropzone is initialized. You\n  // can (and should) setup event listeners inside this function.\n  init() {\n    // In case it isn't set already\n    if (this.element.tagName === \"form\") {\n      this.element.setAttribute(\"enctype\", \"multipart/form-data\");\n    }\n\n    if (\n      this.element.classList.contains(\"dropzone\") &&\n      !this.element.querySelector(\".dz-message\")\n    ) {\n      this.element.appendChild(\n        Dropzone.createElement(\n          `<div class=\"dz-default dz-message\"><button class=\"dz-button\" type=\"button\">${this.options.dictDefaultMessage}</button></div>`\n        )\n      );\n    }\n\n    if (this.clickableElements.length) {\n      let setupHiddenFileInput = () => {\n        if (this.hiddenFileInput) {\n          this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);\n        }\n        this.hiddenFileInput = document.createElement(\"input\");\n        this.hiddenFileInput.setAttribute(\"type\", \"file\");\n        if (this.options.maxFiles === null || this.options.maxFiles > 1) {\n          this.hiddenFileInput.setAttribute(\"multiple\", \"multiple\");\n        }\n        this.hiddenFileInput.className = \"dz-hidden-input\";\n\n        if (this.options.acceptedFiles !== null) {\n          this.hiddenFileInput.setAttribute(\n            \"accept\",\n            this.options.acceptedFiles\n          );\n        }\n        if (this.options.capture !== null) {\n          this.hiddenFileInput.setAttribute(\"capture\", this.options.capture);\n        }\n\n        // Making sure that no one can \"tab\" into this field.\n        this.hiddenFileInput.setAttribute(\"tabindex\", \"-1\");\n\n        // Not setting `display=\"none\"` because some browsers don't accept clicks\n        // on elements that aren't displayed.\n        this.hiddenFileInput.style.visibility = \"hidden\";\n        this.hiddenFileInput.style.position = \"absolute\";\n        this.hiddenFileInput.style.top = \"0\";\n        this.hiddenFileInput.style.left = \"0\";\n        this.hiddenFileInput.style.height = \"0\";\n        this.hiddenFileInput.style.width = \"0\";\n        Dropzone.getElement(\n          this.options.hiddenInputContainer,\n          \"hiddenInputContainer\"\n        ).appendChild(this.hiddenFileInput);\n        this.hiddenFileInput.addEventListener(\"change\", () => {\n          let { files } = this.hiddenFileInput;\n          if (files.length) {\n            for (let file of files) {\n              this.addFile(file);\n            }\n          }\n          this.emit(\"addedfiles\", files);\n          setupHiddenFileInput();\n        });\n      };\n      setupHiddenFileInput();\n    }\n\n    this.URL = window.URL !== null ? window.URL : window.webkitURL;\n\n    // Setup all event listeners on the Dropzone object itself.\n    // They're not in @setupEventListeners() because they shouldn't be removed\n    // again when the dropzone gets disabled.\n    for (let eventName of this.events) {\n      this.on(eventName, this.options[eventName]);\n    }\n\n    this.on(\"uploadprogress\", () => this.updateTotalUploadProgress());\n\n    this.on(\"removedfile\", () => this.updateTotalUploadProgress());\n\n    this.on(\"canceled\", (file) => this.emit(\"complete\", file));\n\n    // Emit a `queuecomplete` event if all files finished uploading.\n    this.on(\"complete\", (file) => {\n      if (\n        this.getAddedFiles().length === 0 &&\n        this.getUploadingFiles().length === 0 &&\n        this.getQueuedFiles().length === 0\n      ) {\n        // This needs to be deferred so that `queuecomplete` really triggers after `complete`\n        return setTimeout(() => this.emit(\"queuecomplete\"), 0);\n      }\n    });\n\n    const containsFiles = function (e) {\n      if (e.dataTransfer.types) {\n        // Because e.dataTransfer.types is an Object in\n        // IE, we need to iterate like this instead of\n        // using e.dataTransfer.types.some()\n        for (var i = 0; i < e.dataTransfer.types.length; i++) {\n          if (e.dataTransfer.types[i] === \"Files\") return true;\n        }\n      }\n      return false;\n    };\n\n    let noPropagation = function (e) {\n      // If there are no files, we don't want to stop\n      // propagation so we don't interfere with other\n      // drag and drop behaviour.\n      if (!containsFiles(e)) return;\n      e.stopPropagation();\n      if (e.preventDefault) {\n        return e.preventDefault();\n      } else {\n        return (e.returnValue = false);\n      }\n    };\n\n    // Create the listeners\n    this.listeners = [\n      {\n        element: this.element,\n        events: {\n          dragstart: (e) => {\n            return this.emit(\"dragstart\", e);\n          },\n          dragenter: (e) => {\n            noPropagation(e);\n            return this.emit(\"dragenter\", e);\n          },\n          dragover: (e) => {\n            // Makes it possible to drag files from chrome's download bar\n            // http://stackoverflow.com/questions/19526430/drag-and-drop-file-uploads-from-chrome-downloads-bar\n            // Try is required to prevent bug in Internet Explorer 11 (SCRIPT65535 exception)\n            let efct;\n            try {\n              efct = e.dataTransfer.effectAllowed;\n            } catch (error) {}\n            e.dataTransfer.dropEffect =\n              \"move\" === efct || \"linkMove\" === efct ? \"move\" : \"copy\";\n\n            noPropagation(e);\n            return this.emit(\"dragover\", e);\n          },\n          dragleave: (e) => {\n            return this.emit(\"dragleave\", e);\n          },\n          drop: (e) => {\n            noPropagation(e);\n            return this.drop(e);\n          },\n          dragend: (e) => {\n            return this.emit(\"dragend\", e);\n          },\n        },\n\n        // This is disabled right now, because the browsers don't implement it properly.\n        // \"paste\": (e) =>\n        //   noPropagation e\n        //   @paste e\n      },\n    ];\n\n    this.clickableElements.forEach((clickableElement) => {\n      return this.listeners.push({\n        element: clickableElement,\n        events: {\n          click: (evt) => {\n            // Only the actual dropzone or the message element should trigger file selection\n            if (\n              clickableElement !== this.element ||\n              evt.target === this.element ||\n              Dropzone.elementInside(\n                evt.target,\n                this.element.querySelector(\".dz-message\")\n              )\n            ) {\n              this.hiddenFileInput.click(); // Forward the click\n            }\n            return true;\n          },\n        },\n      });\n    });\n\n    this.enable();\n\n    return this.options.init.call(this);\n  }\n\n  // Not fully tested yet\n  destroy() {\n    this.disable();\n    this.removeAllFiles(true);\n    if (\n      this.hiddenFileInput != null ? this.hiddenFileInput.parentNode : undefined\n    ) {\n      this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);\n      this.hiddenFileInput = null;\n    }\n    delete this.element.dropzone;\n    return Dropzone.instances.splice(Dropzone.instances.indexOf(this), 1);\n  }\n\n  updateTotalUploadProgress() {\n    let totalUploadProgress;\n    let totalBytesSent = 0;\n    let totalBytes = 0;\n\n    let activeFiles = this.getActiveFiles();\n\n    if (activeFiles.length) {\n      for (let file of this.getActiveFiles()) {\n        totalBytesSent += file.upload.bytesSent;\n        totalBytes += file.upload.total;\n      }\n      totalUploadProgress = (100 * totalBytesSent) / totalBytes;\n    } else {\n      totalUploadProgress = 100;\n    }\n\n    return this.emit(\n      \"totaluploadprogress\",\n      totalUploadProgress,\n      totalBytes,\n      totalBytesSent\n    );\n  }\n\n  // @options.paramName can be a function taking one parameter rather than a string.\n  // A parameter name for a file is obtained simply by calling this with an index number.\n  _getParamName(n) {\n    if (typeof this.options.paramName === \"function\") {\n      return this.options.paramName(n);\n    } else {\n      return `${this.options.paramName}${\n        this.options.uploadMultiple ? `[${n}]` : \"\"\n      }`;\n    }\n  }\n\n  // If @options.renameFile is a function,\n  // the function will be used to rename the file.name before appending it to the formData\n  _renameFile(file) {\n    if (typeof this.options.renameFile !== \"function\") {\n      return file.name;\n    }\n    return this.options.renameFile(file);\n  }\n\n  // Returns a form that can be used as fallback if the browser does not support DragnDrop\n  //\n  // If the dropzone is already a form, only the input field and button are returned. Otherwise a complete form element is provided.\n  // This code has to pass in IE7 :(\n  getFallbackForm() {\n    let existingFallback, form;\n    if ((existingFallback = this.getExistingFallback())) {\n      return existingFallback;\n    }\n\n    let fieldsString = '<div class=\"dz-fallback\">';\n    if (this.options.dictFallbackText) {\n      fieldsString += `<p>${this.options.dictFallbackText}</p>`;\n    }\n    fieldsString += `<input type=\"file\" name=\"${this._getParamName(0)}\" ${\n      this.options.uploadMultiple ? 'multiple=\"multiple\"' : undefined\n    } /><input type=\"submit\" value=\"Upload!\"></div>`;\n\n    let fields = Dropzone.createElement(fieldsString);\n    if (this.element.tagName !== \"FORM\") {\n      form = Dropzone.createElement(\n        `<form action=\"${this.options.url}\" enctype=\"multipart/form-data\" method=\"${this.options.method}\"></form>`\n      );\n      form.appendChild(fields);\n    } else {\n      // Make sure that the enctype and method attributes are set properly\n      this.element.setAttribute(\"enctype\", \"multipart/form-data\");\n      this.element.setAttribute(\"method\", this.options.method);\n    }\n    return form != null ? form : fields;\n  }\n\n  // Returns the fallback elements if they exist already\n  //\n  // This code has to pass in IE7 :(\n  getExistingFallback() {\n    let getFallback = function (elements) {\n      for (let el of elements) {\n        if (/(^| )fallback($| )/.test(el.className)) {\n          return el;\n        }\n      }\n    };\n\n    for (let tagName of [\"div\", \"form\"]) {\n      var fallback;\n      if (\n        (fallback = getFallback(this.element.getElementsByTagName(tagName)))\n      ) {\n        return fallback;\n      }\n    }\n  }\n\n  // Activates all listeners stored in @listeners\n  setupEventListeners() {\n    return this.listeners.map((elementListeners) =>\n      (() => {\n        let result = [];\n        for (let event in elementListeners.events) {\n          let listener = elementListeners.events[event];\n          result.push(\n            elementListeners.element.addEventListener(event, listener, false)\n          );\n        }\n        return result;\n      })()\n    );\n  }\n\n  // Deactivates all listeners stored in @listeners\n  removeEventListeners() {\n    return this.listeners.map((elementListeners) =>\n      (() => {\n        let result = [];\n        for (let event in elementListeners.events) {\n          let listener = elementListeners.events[event];\n          result.push(\n            elementListeners.element.removeEventListener(event, listener, false)\n          );\n        }\n        return result;\n      })()\n    );\n  }\n\n  // Removes all event listeners and cancels all files in the queue or being processed.\n  disable() {\n    this.clickableElements.forEach((element) =>\n      element.classList.remove(\"dz-clickable\")\n    );\n    this.removeEventListeners();\n    this.disabled = true;\n\n    return this.files.map((file) => this.cancelUpload(file));\n  }\n\n  enable() {\n    delete this.disabled;\n    this.clickableElements.forEach((element) =>\n      element.classList.add(\"dz-clickable\")\n    );\n    return this.setupEventListeners();\n  }\n\n  // Returns a nicely formatted filesize\n  filesize(size) {\n    let selectedSize = 0;\n    let selectedUnit = \"b\";\n\n    if (size > 0) {\n      let units = [\"tb\", \"gb\", \"mb\", \"kb\", \"b\"];\n\n      for (let i = 0; i < units.length; i++) {\n        let unit = units[i];\n        let cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;\n\n        if (size >= cutoff) {\n          selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);\n          selectedUnit = unit;\n          break;\n        }\n      }\n\n      selectedSize = Math.round(10 * selectedSize) / 10; // Cutting of digits\n    }\n\n    return `<strong>${selectedSize}</strong> ${this.options.dictFileSizeUnits[selectedUnit]}`;\n  }\n\n  // Adds or removes the `dz-max-files-reached` class from the form.\n  _updateMaxFilesReachedClass() {\n    if (\n      this.options.maxFiles != null &&\n      this.getAcceptedFiles().length >= this.options.maxFiles\n    ) {\n      if (this.getAcceptedFiles().length === this.options.maxFiles) {\n        this.emit(\"maxfilesreached\", this.files);\n      }\n      return this.element.classList.add(\"dz-max-files-reached\");\n    } else {\n      return this.element.classList.remove(\"dz-max-files-reached\");\n    }\n  }\n\n  drop(e) {\n    if (!e.dataTransfer) {\n      return;\n    }\n    this.emit(\"drop\", e);\n\n    // Convert the FileList to an Array\n    // This is necessary for IE11\n    let files = [];\n    for (let i = 0; i < e.dataTransfer.files.length; i++) {\n      files[i] = e.dataTransfer.files[i];\n    }\n\n    // Even if it's a folder, files.length will contain the folders.\n    if (files.length) {\n      let { items } = e.dataTransfer;\n      if (items && items.length && items[0].webkitGetAsEntry != null) {\n        // The browser supports dropping of folders, so handle items instead of files\n        this._addFilesFromItems(items);\n      } else {\n        this.handleFiles(files);\n      }\n    }\n\n    this.emit(\"addedfiles\", files);\n  }\n\n  paste(e) {\n    if (\n      __guard__(e != null ? e.clipboardData : undefined, (x) => x.items) == null\n    ) {\n      return;\n    }\n\n    this.emit(\"paste\", e);\n    let { items } = e.clipboardData;\n\n    if (items.length) {\n      return this._addFilesFromItems(items);\n    }\n  }\n\n  handleFiles(files) {\n    for (let file of files) {\n      this.addFile(file);\n    }\n  }\n\n  // When a folder is dropped (or files are pasted), items must be handled\n  // instead of files.\n  _addFilesFromItems(items) {\n    return (() => {\n      let result = [];\n      for (let item of items) {\n        var entry;\n        if (\n          item.webkitGetAsEntry != null &&\n          (entry = item.webkitGetAsEntry())\n        ) {\n          if (entry.isFile) {\n            result.push(this.addFile(item.getAsFile()));\n          } else if (entry.isDirectory) {\n            // Append all files from that directory to files\n            result.push(this._addFilesFromDirectory(entry, entry.name));\n          } else {\n            result.push(undefined);\n          }\n        } else if (item.getAsFile != null) {\n          if (item.kind == null || item.kind === \"file\") {\n            result.push(this.addFile(item.getAsFile()));\n          } else {\n            result.push(undefined);\n          }\n        } else {\n          result.push(undefined);\n        }\n      }\n      return result;\n    })();\n  }\n\n  // Goes through the directory, and adds each file it finds recursively\n  _addFilesFromDirectory(directory, path) {\n    let dirReader = directory.createReader();\n\n    let errorHandler = (error) =>\n      __guardMethod__(console, \"log\", (o) => o.log(error));\n\n    var readEntries = () => {\n      return dirReader.readEntries((entries) => {\n        if (entries.length > 0) {\n          for (let entry of entries) {\n            if (entry.isFile) {\n              entry.file((file) => {\n                if (\n                  this.options.ignoreHiddenFiles &&\n                  file.name.substring(0, 1) === \".\"\n                ) {\n                  return;\n                }\n                file.fullPath = `${path}/${file.name}`;\n                return this.addFile(file);\n              });\n            } else if (entry.isDirectory) {\n              this._addFilesFromDirectory(entry, `${path}/${entry.name}`);\n            }\n          }\n\n          // Recursively call readEntries() again, since browser only handle\n          // the first 100 entries.\n          // See: https://developer.mozilla.org/en-US/docs/Web/API/DirectoryReader#readEntries\n          readEntries();\n        }\n        return null;\n      }, errorHandler);\n    };\n\n    return readEntries();\n  }\n\n  // If `done()` is called without argument the file is accepted\n  // If you call it with an error message, the file is rejected\n  // (This allows for asynchronous validation)\n  //\n  // This function checks the filesize, and if the file.type passes the\n  // `acceptedFiles` check.\n  accept(file, done) {\n    if (\n      this.options.maxFilesize &&\n      file.size > this.options.maxFilesize * 1024 * 1024\n    ) {\n      done(\n        this.options.dictFileTooBig\n          .replace(\"{{filesize}}\", Math.round(file.size / 1024 / 10.24) / 100)\n          .replace(\"{{maxFilesize}}\", this.options.maxFilesize)\n      );\n    } else if (!Dropzone.isValidFile(file, this.options.acceptedFiles)) {\n      done(this.options.dictInvalidFileType);\n    } else if (\n      this.options.maxFiles != null &&\n      this.getAcceptedFiles().length >= this.options.maxFiles\n    ) {\n      done(\n        this.options.dictMaxFilesExceeded.replace(\n          \"{{maxFiles}}\",\n          this.options.maxFiles\n        )\n      );\n      this.emit(\"maxfilesexceeded\", file);\n    } else {\n      this.options.accept.call(this, file, done);\n    }\n  }\n\n  addFile(file) {\n    file.upload = {\n      uuid: Dropzone.uuidv4(),\n      progress: 0,\n      // Setting the total upload size to file.size for the beginning\n      // It's actual different than the size to be transmitted.\n      total: file.size,\n      bytesSent: 0,\n      filename: this._renameFile(file),\n      // Not setting chunking information here, because the acutal data — and\n      // thus the chunks — might change if `options.transformFile` is set\n      // and does something to the data.\n    };\n    this.files.push(file);\n\n    file.status = Dropzone.ADDED;\n\n    this.emit(\"addedfile\", file);\n\n    this._enqueueThumbnail(file);\n\n    this.accept(file, (error) => {\n      if (error) {\n        file.accepted = false;\n        this._errorProcessing([file], error); // Will set the file.status\n      } else {\n        file.accepted = true;\n        if (this.options.autoQueue) {\n          this.enqueueFile(file);\n        } // Will set .accepted = true\n      }\n      this._updateMaxFilesReachedClass();\n    });\n  }\n\n  // Wrapper for enqueueFile\n  enqueueFiles(files) {\n    for (let file of files) {\n      this.enqueueFile(file);\n    }\n    return null;\n  }\n\n  enqueueFile(file) {\n    if (file.status === Dropzone.ADDED && file.accepted === true) {\n      file.status = Dropzone.QUEUED;\n      if (this.options.autoProcessQueue) {\n        return setTimeout(() => this.processQueue(), 0); // Deferring the call\n      }\n    } else {\n      throw new Error(\n        \"This file can't be queued because it has already been processed or was rejected.\"\n      );\n    }\n  }\n\n  _enqueueThumbnail(file) {\n    if (\n      this.options.createImageThumbnails &&\n      file.type.match(/image.*/) &&\n      file.size <= this.options.maxThumbnailFilesize * 1024 * 1024\n    ) {\n      this._thumbnailQueue.push(file);\n      return setTimeout(() => this._processThumbnailQueue(), 0); // Deferring the call\n    }\n  }\n\n  _processThumbnailQueue() {\n    if (this._processingThumbnail || this._thumbnailQueue.length === 0) {\n      return;\n    }\n\n    this._processingThumbnail = true;\n    let file = this._thumbnailQueue.shift();\n    return this.createThumbnail(\n      file,\n      this.options.thumbnailWidth,\n      this.options.thumbnailHeight,\n      this.options.thumbnailMethod,\n      true,\n      (dataUrl) => {\n        this.emit(\"thumbnail\", file, dataUrl);\n        this._processingThumbnail = false;\n        return this._processThumbnailQueue();\n      }\n    );\n  }\n\n  // Can be called by the user to remove a file\n  removeFile(file) {\n    if (file.status === Dropzone.UPLOADING) {\n      this.cancelUpload(file);\n    }\n    this.files = without(this.files, file);\n\n    this.emit(\"removedfile\", file);\n    if (this.files.length === 0) {\n      return this.emit(\"reset\");\n    }\n  }\n\n  // Removes all files that aren't currently processed from the list\n  removeAllFiles(cancelIfNecessary) {\n    // Create a copy of files since removeFile() changes the @files array.\n    if (cancelIfNecessary == null) {\n      cancelIfNecessary = false;\n    }\n    for (let file of this.files.slice()) {\n      if (file.status !== Dropzone.UPLOADING || cancelIfNecessary) {\n        this.removeFile(file);\n      }\n    }\n    return null;\n  }\n\n  // Resizes an image before it gets sent to the server. This function is the default behavior of\n  // `options.transformFile` if `resizeWidth` or `resizeHeight` are set. The callback is invoked with\n  // the resized blob.\n  resizeImage(file, width, height, resizeMethod, callback) {\n    return this.createThumbnail(\n      file,\n      width,\n      height,\n      resizeMethod,\n      true,\n      (dataUrl, canvas) => {\n        if (canvas == null) {\n          // The image has not been resized\n          return callback(file);\n        } else {\n          let { resizeMimeType } = this.options;\n          if (resizeMimeType == null) {\n            resizeMimeType = file.type;\n          }\n          let resizedDataURL = canvas.toDataURL(\n            resizeMimeType,\n            this.options.resizeQuality\n          );\n          if (\n            resizeMimeType === \"image/jpeg\" ||\n            resizeMimeType === \"image/jpg\"\n          ) {\n            // Now add the original EXIF information\n            resizedDataURL = ExifRestore.restore(file.dataURL, resizedDataURL);\n          }\n          return callback(Dropzone.dataURItoBlob(resizedDataURL));\n        }\n      }\n    );\n  }\n\n  createThumbnail(file, width, height, resizeMethod, fixOrientation, callback) {\n    let fileReader = new FileReader();\n\n    fileReader.onload = () => {\n      file.dataURL = fileReader.result;\n\n      // Don't bother creating a thumbnail for SVG images since they're vector\n      if (file.type === \"image/svg+xml\") {\n        if (callback != null) {\n          callback(fileReader.result);\n        }\n        return;\n      }\n\n      this.createThumbnailFromUrl(\n        file,\n        width,\n        height,\n        resizeMethod,\n        fixOrientation,\n        callback\n      );\n    };\n\n    fileReader.readAsDataURL(file);\n  }\n\n  // `mockFile` needs to have these attributes:\n  //\n  //     { name: 'name', size: 12345, imageUrl: '' }\n  //\n  // `callback` will be invoked when the image has been downloaded and displayed.\n  // `crossOrigin` will be added to the `img` tag when accessing the file.\n  displayExistingFile(\n    mockFile,\n    imageUrl,\n    callback,\n    crossOrigin,\n    resizeThumbnail = true\n  ) {\n    this.emit(\"addedfile\", mockFile);\n    this.emit(\"complete\", mockFile);\n\n    if (!resizeThumbnail) {\n      this.emit(\"thumbnail\", mockFile, imageUrl);\n      if (callback) callback();\n    } else {\n      let onDone = (thumbnail) => {\n        this.emit(\"thumbnail\", mockFile, thumbnail);\n        if (callback) callback();\n      };\n      mockFile.dataURL = imageUrl;\n\n      this.createThumbnailFromUrl(\n        mockFile,\n        this.options.thumbnailWidth,\n        this.options.thumbnailHeight,\n        this.options.resizeMethod,\n        this.options.fixOrientation,\n        onDone,\n        crossOrigin\n      );\n    }\n  }\n\n  createThumbnailFromUrl(\n    file,\n    width,\n    height,\n    resizeMethod,\n    fixOrientation,\n    callback,\n    crossOrigin\n  ) {\n    // Not using `new Image` here because of a bug in latest Chrome versions.\n    // See https://github.com/enyo/dropzone/pull/226\n    let img = document.createElement(\"img\");\n\n    if (crossOrigin) {\n      img.crossOrigin = crossOrigin;\n    }\n\n    // fixOrientation is not needed anymore with browsers handling imageOrientation\n    fixOrientation =\n      getComputedStyle(document.body)[\"imageOrientation\"] == \"from-image\"\n        ? false\n        : fixOrientation;\n\n    img.onload = () => {\n      let loadExif = (callback) => callback(1);\n      if (typeof EXIF !== \"undefined\" && EXIF !== null && fixOrientation) {\n        loadExif = (callback) =>\n          EXIF.getData(img, function () {\n            return callback(EXIF.getTag(this, \"Orientation\"));\n          });\n      }\n\n      return loadExif((orientation) => {\n        file.width = img.width;\n        file.height = img.height;\n\n        let resizeInfo = this.options.resize.call(\n          this,\n          file,\n          width,\n          height,\n          resizeMethod\n        );\n\n        let canvas = document.createElement(\"canvas\");\n        let ctx = canvas.getContext(\"2d\");\n\n        canvas.width = resizeInfo.trgWidth;\n        canvas.height = resizeInfo.trgHeight;\n\n        if (orientation > 4) {\n          canvas.width = resizeInfo.trgHeight;\n          canvas.height = resizeInfo.trgWidth;\n        }\n\n        switch (orientation) {\n          case 2:\n            // horizontal flip\n            ctx.translate(canvas.width, 0);\n            ctx.scale(-1, 1);\n            break;\n          case 3:\n            // 180° rotate left\n            ctx.translate(canvas.width, canvas.height);\n            ctx.rotate(Math.PI);\n            break;\n          case 4:\n            // vertical flip\n            ctx.translate(0, canvas.height);\n            ctx.scale(1, -1);\n            break;\n          case 5:\n            // vertical flip + 90 rotate right\n            ctx.rotate(0.5 * Math.PI);\n            ctx.scale(1, -1);\n            break;\n          case 6:\n            // 90° rotate right\n            ctx.rotate(0.5 * Math.PI);\n            ctx.translate(0, -canvas.width);\n            break;\n          case 7:\n            // horizontal flip + 90 rotate right\n            ctx.rotate(0.5 * Math.PI);\n            ctx.translate(canvas.height, -canvas.width);\n            ctx.scale(-1, 1);\n            break;\n          case 8:\n            // 90° rotate left\n            ctx.rotate(-0.5 * Math.PI);\n            ctx.translate(-canvas.height, 0);\n            break;\n        }\n\n        // This is a bugfix for iOS' scaling bug.\n        drawImageIOSFix(\n          ctx,\n          img,\n          resizeInfo.srcX != null ? resizeInfo.srcX : 0,\n          resizeInfo.srcY != null ? resizeInfo.srcY : 0,\n          resizeInfo.srcWidth,\n          resizeInfo.srcHeight,\n          resizeInfo.trgX != null ? resizeInfo.trgX : 0,\n          resizeInfo.trgY != null ? resizeInfo.trgY : 0,\n          resizeInfo.trgWidth,\n          resizeInfo.trgHeight\n        );\n\n        let thumbnail = canvas.toDataURL(\"image/png\");\n\n        if (callback != null) {\n          return callback(thumbnail, canvas);\n        }\n      });\n    };\n\n    if (callback != null) {\n      img.onerror = callback;\n    }\n\n    return (img.src = file.dataURL);\n  }\n\n  // Goes through the queue and processes files if there aren't too many already.\n  processQueue() {\n    let { parallelUploads } = this.options;\n    let processingLength = this.getUploadingFiles().length;\n    let i = processingLength;\n\n    // There are already at least as many files uploading than should be\n    if (processingLength >= parallelUploads) {\n      return;\n    }\n\n    let queuedFiles = this.getQueuedFiles();\n\n    if (!(queuedFiles.length > 0)) {\n      return;\n    }\n\n    if (this.options.uploadMultiple) {\n      // The files should be uploaded in one request\n      return this.processFiles(\n        queuedFiles.slice(0, parallelUploads - processingLength)\n      );\n    } else {\n      while (i < parallelUploads) {\n        if (!queuedFiles.length) {\n          return;\n        } // Nothing left to process\n        this.processFile(queuedFiles.shift());\n        i++;\n      }\n    }\n  }\n\n  // Wrapper for `processFiles`\n  processFile(file) {\n    return this.processFiles([file]);\n  }\n\n  // Loads the file, then calls finishedLoading()\n  processFiles(files) {\n    for (let file of files) {\n      file.processing = true; // Backwards compatibility\n      file.status = Dropzone.UPLOADING;\n\n      this.emit(\"processing\", file);\n    }\n\n    if (this.options.uploadMultiple) {\n      this.emit(\"processingmultiple\", files);\n    }\n\n    return this.uploadFiles(files);\n  }\n\n  _getFilesWithXhr(xhr) {\n    let files;\n    return (files = this.files\n      .filter((file) => file.xhr === xhr)\n      .map((file) => file));\n  }\n\n  // Cancels the file upload and sets the status to CANCELED\n  // **if** the file is actually being uploaded.\n  // If it's still in the queue, the file is being removed from it and the status\n  // set to CANCELED.\n  cancelUpload(file) {\n    if (file.status === Dropzone.UPLOADING) {\n      let groupedFiles = this._getFilesWithXhr(file.xhr);\n      for (let groupedFile of groupedFiles) {\n        groupedFile.status = Dropzone.CANCELED;\n      }\n      if (typeof file.xhr !== \"undefined\") {\n        file.xhr.abort();\n      }\n      for (let groupedFile of groupedFiles) {\n        this.emit(\"canceled\", groupedFile);\n      }\n      if (this.options.uploadMultiple) {\n        this.emit(\"canceledmultiple\", groupedFiles);\n      }\n    } else if (\n      file.status === Dropzone.ADDED ||\n      file.status === Dropzone.QUEUED\n    ) {\n      file.status = Dropzone.CANCELED;\n      this.emit(\"canceled\", file);\n      if (this.options.uploadMultiple) {\n        this.emit(\"canceledmultiple\", [file]);\n      }\n    }\n\n    if (this.options.autoProcessQueue) {\n      return this.processQueue();\n    }\n  }\n\n  resolveOption(option, ...args) {\n    if (typeof option === \"function\") {\n      return option.apply(this, args);\n    }\n    return option;\n  }\n\n  uploadFile(file) {\n    return this.uploadFiles([file]);\n  }\n\n  uploadFiles(files) {\n    this._transformFiles(files, (transformedFiles) => {\n      if (this.options.chunking) {\n        // Chunking is not allowed to be used with `uploadMultiple` so we know\n        // that there is only __one__file.\n        let transformedFile = transformedFiles[0];\n        files[0].upload.chunked =\n          this.options.chunking &&\n          (this.options.forceChunking ||\n            transformedFile.size > this.options.chunkSize);\n        files[0].upload.totalChunkCount = Math.ceil(\n          transformedFile.size / this.options.chunkSize\n        );\n      }\n\n      if (files[0].upload.chunked) {\n        // This file should be sent in chunks!\n\n        // If the chunking option is set, we **know** that there can only be **one** file, since\n        // uploadMultiple is not allowed with this option.\n        let file = files[0];\n        let transformedFile = transformedFiles[0];\n        let startedChunkCount = 0;\n\n        file.upload.chunks = [];\n\n        let handleNextChunk = () => {\n          let chunkIndex = 0;\n\n          // Find the next item in file.upload.chunks that is not defined yet.\n          while (file.upload.chunks[chunkIndex] !== undefined) {\n            chunkIndex++;\n          }\n\n          // This means, that all chunks have already been started.\n          if (chunkIndex >= file.upload.totalChunkCount) return;\n\n          startedChunkCount++;\n\n          let start = chunkIndex * this.options.chunkSize;\n          let end = Math.min(\n            start + this.options.chunkSize,\n            transformedFile.size\n          );\n\n          let dataBlock = {\n            name: this._getParamName(0),\n            data: transformedFile.webkitSlice\n              ? transformedFile.webkitSlice(start, end)\n              : transformedFile.slice(start, end),\n            filename: file.upload.filename,\n            chunkIndex: chunkIndex,\n          };\n\n          file.upload.chunks[chunkIndex] = {\n            file: file,\n            index: chunkIndex,\n            dataBlock: dataBlock, // In case we want to retry.\n            status: Dropzone.UPLOADING,\n            progress: 0,\n            retries: 0, // The number of times this block has been retried.\n          };\n\n          this._uploadData(files, [dataBlock]);\n        };\n\n        file.upload.finishedChunkUpload = (chunk, response) => {\n          let allFinished = true;\n          chunk.status = Dropzone.SUCCESS;\n\n          // Clear the data from the chunk\n          chunk.dataBlock = null;\n          // Leaving this reference to xhr intact here will cause memory leaks in some browsers\n          chunk.xhr = null;\n\n          for (let i = 0; i < file.upload.totalChunkCount; i++) {\n            if (file.upload.chunks[i] === undefined) {\n              return handleNextChunk();\n            }\n            if (file.upload.chunks[i].status !== Dropzone.SUCCESS) {\n              allFinished = false;\n            }\n          }\n\n          if (allFinished) {\n            this.options.chunksUploaded(file, () => {\n              this._finished(files, response, null);\n            });\n          }\n        };\n\n        if (this.options.parallelChunkUploads) {\n          for (let i = 0; i < file.upload.totalChunkCount; i++) {\n            handleNextChunk();\n          }\n        } else {\n          handleNextChunk();\n        }\n      } else {\n        let dataBlocks = [];\n        for (let i = 0; i < files.length; i++) {\n          dataBlocks[i] = {\n            name: this._getParamName(i),\n            data: transformedFiles[i],\n            filename: files[i].upload.filename,\n          };\n        }\n        this._uploadData(files, dataBlocks);\n      }\n    });\n  }\n\n  /// Returns the right chunk for given file and xhr\n  _getChunk(file, xhr) {\n    for (let i = 0; i < file.upload.totalChunkCount; i++) {\n      if (\n        file.upload.chunks[i] !== undefined &&\n        file.upload.chunks[i].xhr === xhr\n      ) {\n        return file.upload.chunks[i];\n      }\n    }\n  }\n\n  // This function actually uploads the file(s) to the server.\n  // If dataBlocks contains the actual data to upload (meaning, that this could either be transformed\n  // files, or individual chunks for chunked upload).\n  _uploadData(files, dataBlocks) {\n    let xhr = new XMLHttpRequest();\n\n    // Put the xhr object in the file objects to be able to reference it later.\n    for (let file of files) {\n      file.xhr = xhr;\n    }\n    if (files[0].upload.chunked) {\n      // Put the xhr object in the right chunk object, so it can be associated later, and found with _getChunk\n      files[0].upload.chunks[dataBlocks[0].chunkIndex].xhr = xhr;\n    }\n\n    let method = this.resolveOption(this.options.method, files);\n    let url = this.resolveOption(this.options.url, files);\n    xhr.open(method, url, true);\n\n    // Setting the timeout after open because of IE11 issue: https://gitlab.com/meno/dropzone/issues/8\n    let timeout = this.resolveOption(this.options.timeout, files);\n    if (timeout) xhr.timeout = this.resolveOption(this.options.timeout, files);\n\n    // Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179\n    xhr.withCredentials = !!this.options.withCredentials;\n\n    xhr.onload = (e) => {\n      this._finishedUploading(files, xhr, e);\n    };\n\n    xhr.ontimeout = () => {\n      this._handleUploadError(\n        files,\n        xhr,\n        `Request timedout after ${this.options.timeout / 1000} seconds`\n      );\n    };\n\n    xhr.onerror = () => {\n      this._handleUploadError(files, xhr);\n    };\n\n    // Some browsers do not have the .upload property\n    let progressObj = xhr.upload != null ? xhr.upload : xhr;\n    progressObj.onprogress = (e) =>\n      this._updateFilesUploadProgress(files, xhr, e);\n\n    let headers = {\n      Accept: \"application/json\",\n      \"Cache-Control\": \"no-cache\",\n      \"X-Requested-With\": \"XMLHttpRequest\",\n    };\n\n    if (this.options.headers) {\n      Dropzone.extend(headers, this.options.headers);\n    }\n\n    for (let headerName in headers) {\n      let headerValue = headers[headerName];\n      if (headerValue) {\n        xhr.setRequestHeader(headerName, headerValue);\n      }\n    }\n\n    let formData = new FormData();\n\n    // Adding all @options parameters\n    if (this.options.params) {\n      let additionalParams = this.options.params;\n      if (typeof additionalParams === \"function\") {\n        additionalParams = additionalParams.call(\n          this,\n          files,\n          xhr,\n          files[0].upload.chunked ? this._getChunk(files[0], xhr) : null\n        );\n      }\n\n      for (let key in additionalParams) {\n        let value = additionalParams[key];\n        if (Array.isArray(value)) {\n          // The additional parameter contains an array,\n          // so lets iterate over it to attach each value\n          // individually.\n          for (let i = 0; i < value.length; i++) {\n            formData.append(key, value[i]);\n          }\n        } else {\n          formData.append(key, value);\n        }\n      }\n    }\n\n    // Let the user add additional data if necessary\n    for (let file of files) {\n      this.emit(\"sending\", file, xhr, formData);\n    }\n    if (this.options.uploadMultiple) {\n      this.emit(\"sendingmultiple\", files, xhr, formData);\n    }\n\n    this._addFormElementData(formData);\n\n    // Finally add the files\n    // Has to be last because some servers (eg: S3) expect the file to be the last parameter\n    for (let i = 0; i < dataBlocks.length; i++) {\n      let dataBlock = dataBlocks[i];\n      formData.append(dataBlock.name, dataBlock.data, dataBlock.filename);\n    }\n\n    this.submitRequest(xhr, formData, files);\n  }\n\n  // Transforms all files with this.options.transformFile and invokes done with the transformed files when done.\n  _transformFiles(files, done) {\n    let transformedFiles = [];\n    // Clumsy way of handling asynchronous calls, until I get to add a proper Future library.\n    let doneCounter = 0;\n    for (let i = 0; i < files.length; i++) {\n      this.options.transformFile.call(this, files[i], (transformedFile) => {\n        transformedFiles[i] = transformedFile;\n        if (++doneCounter === files.length) {\n          done(transformedFiles);\n        }\n      });\n    }\n  }\n\n  // Takes care of adding other input elements of the form to the AJAX request\n  _addFormElementData(formData) {\n    // Take care of other input elements\n    if (this.element.tagName === \"FORM\") {\n      for (let input of this.element.querySelectorAll(\n        \"input, textarea, select, button\"\n      )) {\n        let inputName = input.getAttribute(\"name\");\n        let inputType = input.getAttribute(\"type\");\n        if (inputType) inputType = inputType.toLowerCase();\n\n        // If the input doesn't have a name, we can't use it.\n        if (typeof inputName === \"undefined\" || inputName === null) continue;\n\n        if (input.tagName === \"SELECT\" && input.hasAttribute(\"multiple\")) {\n          // Possibly multiple values\n          for (let option of input.options) {\n            if (option.selected) {\n              formData.append(inputName, option.value);\n            }\n          }\n        } else if (\n          !inputType ||\n          (inputType !== \"checkbox\" && inputType !== \"radio\") ||\n          input.checked\n        ) {\n          formData.append(inputName, input.value);\n        }\n      }\n    }\n  }\n\n  // Invoked when there is new progress information about given files.\n  // If e is not provided, it is assumed that the upload is finished.\n  _updateFilesUploadProgress(files, xhr, e) {\n    if (!files[0].upload.chunked) {\n      // Handle file uploads without chunking\n      for (let file of files) {\n        if (\n          file.upload.total &&\n          file.upload.bytesSent &&\n          file.upload.bytesSent == file.upload.total\n        ) {\n          // If both, the `total` and `bytesSent` have already been set, and\n          // they are equal (meaning progress is at 100%), we can skip this\n          // file, since an upload progress shouldn't go down.\n          continue;\n        }\n\n        if (e) {\n          file.upload.progress = (100 * e.loaded) / e.total;\n          file.upload.total = e.total;\n          file.upload.bytesSent = e.loaded;\n        } else {\n          // No event, so we're at 100%\n          file.upload.progress = 100;\n          file.upload.bytesSent = file.upload.total;\n        }\n\n        this.emit(\n          \"uploadprogress\",\n          file,\n          file.upload.progress,\n          file.upload.bytesSent\n        );\n      }\n    } else {\n      // Handle chunked file uploads\n\n      // Chunked upload is not compatible with uploading multiple files in one\n      // request, so we know there's only one file.\n      let file = files[0];\n\n      // Since this is a chunked upload, we need to update the appropriate chunk\n      // progress.\n      let chunk = this._getChunk(file, xhr);\n\n      if (e) {\n        chunk.progress = (100 * e.loaded) / e.total;\n        chunk.total = e.total;\n        chunk.bytesSent = e.loaded;\n      } else {\n        // No event, so we're at 100%\n        chunk.progress = 100;\n        chunk.bytesSent = chunk.total;\n      }\n\n      // Now tally the *file* upload progress from its individual chunks\n      file.upload.progress = 0;\n      file.upload.total = 0;\n      file.upload.bytesSent = 0;\n      for (let i = 0; i < file.upload.totalChunkCount; i++) {\n        if (\n          file.upload.chunks[i] &&\n          typeof file.upload.chunks[i].progress !== \"undefined\"\n        ) {\n          file.upload.progress += file.upload.chunks[i].progress;\n          file.upload.total += file.upload.chunks[i].total;\n          file.upload.bytesSent += file.upload.chunks[i].bytesSent;\n        }\n      }\n      // Since the process is a percentage, we need to divide by the amount of\n      // chunks we've used.\n      file.upload.progress = file.upload.progress / file.upload.totalChunkCount;\n\n      this.emit(\n        \"uploadprogress\",\n        file,\n        file.upload.progress,\n        file.upload.bytesSent\n      );\n    }\n  }\n\n  _finishedUploading(files, xhr, e) {\n    let response;\n\n    if (files[0].status === Dropzone.CANCELED) {\n      return;\n    }\n\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    if (xhr.responseType !== \"arraybuffer\" && xhr.responseType !== \"blob\") {\n      response = xhr.responseText;\n\n      if (\n        xhr.getResponseHeader(\"content-type\") &&\n        ~xhr.getResponseHeader(\"content-type\").indexOf(\"application/json\")\n      ) {\n        try {\n          response = JSON.parse(response);\n        } catch (error) {\n          e = error;\n          response = \"Invalid JSON response from server.\";\n        }\n      }\n    }\n\n    this._updateFilesUploadProgress(files, xhr);\n\n    if (!(200 <= xhr.status && xhr.status < 300)) {\n      this._handleUploadError(files, xhr, response);\n    } else {\n      if (files[0].upload.chunked) {\n        files[0].upload.finishedChunkUpload(\n          this._getChunk(files[0], xhr),\n          response\n        );\n      } else {\n        this._finished(files, response, e);\n      }\n    }\n  }\n\n  _handleUploadError(files, xhr, response) {\n    if (files[0].status === Dropzone.CANCELED) {\n      return;\n    }\n\n    if (files[0].upload.chunked && this.options.retryChunks) {\n      let chunk = this._getChunk(files[0], xhr);\n      if (chunk.retries++ < this.options.retryChunksLimit) {\n        this._uploadData(files, [chunk.dataBlock]);\n        return;\n      } else {\n        console.warn(\"Retried this chunk too often. Giving up.\");\n      }\n    }\n\n    this._errorProcessing(\n      files,\n      response ||\n        this.options.dictResponseError.replace(\"{{statusCode}}\", xhr.status),\n      xhr\n    );\n  }\n\n  submitRequest(xhr, formData, files) {\n    if (xhr.readyState != 1) {\n      console.warn(\n        \"Cannot send this request because the XMLHttpRequest.readyState is not OPENED.\"\n      );\n      return;\n    }\n    xhr.send(formData);\n  }\n\n  // Called internally when processing is finished.\n  // Individual callbacks have to be called in the appropriate sections.\n  _finished(files, responseText, e) {\n    for (let file of files) {\n      file.status = Dropzone.SUCCESS;\n      this.emit(\"success\", file, responseText, e);\n      this.emit(\"complete\", file);\n    }\n    if (this.options.uploadMultiple) {\n      this.emit(\"successmultiple\", files, responseText, e);\n      this.emit(\"completemultiple\", files);\n    }\n\n    if (this.options.autoProcessQueue) {\n      return this.processQueue();\n    }\n  }\n\n  // Called internally when processing is finished.\n  // Individual callbacks have to be called in the appropriate sections.\n  _errorProcessing(files, message, xhr) {\n    for (let file of files) {\n      file.status = Dropzone.ERROR;\n      this.emit(\"error\", file, message, xhr);\n      this.emit(\"complete\", file);\n    }\n    if (this.options.uploadMultiple) {\n      this.emit(\"errormultiple\", files, message, xhr);\n      this.emit(\"completemultiple\", files);\n    }\n\n    if (this.options.autoProcessQueue) {\n      return this.processQueue();\n    }\n  }\n\n  static uuidv4() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(\n      /[xy]/g,\n      function (c) {\n        let r = (Math.random() * 16) | 0,\n          v = c === \"x\" ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n      }\n    );\n  }\n}\nDropzone.initClass();\n\nDropzone.version = \"dev\";\n\n// This is a map of options for your different dropzones. Add configurations\n// to this object for your different dropzone elemens.\n//\n// Example:\n//\n//     Dropzone.options.myDropzoneElementId = { maxFilesize: 1 };\n//\n// To disable autoDiscover for a specific element, you can set `false` as an option:\n//\n//     Dropzone.options.myDisabledElementId = false;\n//\n// And in html:\n//\n//     <form action=\"/upload\" id=\"my-dropzone-element-id\" class=\"dropzone\"></form>\nDropzone.options = {};\n\n// Returns the options for an element or undefined if none available.\nDropzone.optionsForElement = function (element) {\n  // Get the `Dropzone.options.elementId` for this element if it exists\n  if (element.getAttribute(\"id\")) {\n    return Dropzone.options[camelize(element.getAttribute(\"id\"))];\n  } else {\n    return undefined;\n  }\n};\n\n// Holds a list of all dropzone instances\nDropzone.instances = [];\n\n// Returns the dropzone for given element if any\nDropzone.forElement = function (element) {\n  if (typeof element === \"string\") {\n    element = document.querySelector(element);\n  }\n  if ((element != null ? element.dropzone : undefined) == null) {\n    throw new Error(\n      \"No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.\"\n    );\n  }\n  return element.dropzone;\n};\n\n// Set to false if you don't want Dropzone to automatically find and attach to .dropzone elements.\nDropzone.autoDiscover = true;\n\n// Looks for all .dropzone elements and creates a dropzone for them\nDropzone.discover = function () {\n  let dropzones;\n  if (document.querySelectorAll) {\n    dropzones = document.querySelectorAll(\".dropzone\");\n  } else {\n    dropzones = [];\n    // IE :(\n    let checkElements = (elements) =>\n      (() => {\n        let result = [];\n        for (let el of elements) {\n          if (/(^| )dropzone($| )/.test(el.className)) {\n            result.push(dropzones.push(el));\n          } else {\n            result.push(undefined);\n          }\n        }\n        return result;\n      })();\n    checkElements(document.getElementsByTagName(\"div\"));\n    checkElements(document.getElementsByTagName(\"form\"));\n  }\n\n  return (() => {\n    let result = [];\n    for (let dropzone of dropzones) {\n      // Create a dropzone unless auto discover has been disabled for specific element\n      if (Dropzone.optionsForElement(dropzone) !== false) {\n        result.push(new Dropzone(dropzone));\n      } else {\n        result.push(undefined);\n      }\n    }\n    return result;\n  })();\n};\n\n// Some browsers support drag and drog functionality, but not correctly.\n//\n// So I created a blocklist of userAgents. Yes, yes. Browser sniffing, I know.\n// But what to do when browsers *theoretically* support an API, but crash\n// when using it.\n//\n// This is a list of regular expressions tested against navigator.userAgent\n//\n// ** It should only be used on browser that *do* support the API, but\n// incorrectly **\nDropzone.blockedBrowsers = [\n  // The mac os and windows phone version of opera 12 seems to have a problem with the File drag'n'drop API.\n  /opera.*(Macintosh|Windows Phone).*version\\/12/i,\n];\n\n// Checks if the browser is supported\nDropzone.isBrowserSupported = function () {\n  let capableBrowser = true;\n\n  if (\n    window.File &&\n    window.FileReader &&\n    window.FileList &&\n    window.Blob &&\n    window.FormData &&\n    document.querySelector\n  ) {\n    if (!(\"classList\" in document.createElement(\"a\"))) {\n      capableBrowser = false;\n    } else {\n      if (Dropzone.blacklistedBrowsers !== undefined) {\n        // Since this has been renamed, this makes sure we don't break older\n        // configuration.\n        Dropzone.blockedBrowsers = Dropzone.blacklistedBrowsers;\n      }\n      // The browser supports the API, but may be blocked.\n      for (let regex of Dropzone.blockedBrowsers) {\n        if (regex.test(navigator.userAgent)) {\n          capableBrowser = false;\n          continue;\n        }\n      }\n    }\n  } else {\n    capableBrowser = false;\n  }\n\n  return capableBrowser;\n};\n\nDropzone.dataURItoBlob = function (dataURI) {\n  // convert base64 to raw binary data held in a string\n  // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this\n  let byteString = atob(dataURI.split(\",\")[1]);\n\n  // separate out the mime component\n  let mimeString = dataURI.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n\n  // write the bytes of the string to an ArrayBuffer\n  let ab = new ArrayBuffer(byteString.length);\n  let ia = new Uint8Array(ab);\n  for (\n    let i = 0, end = byteString.length, asc = 0 <= end;\n    asc ? i <= end : i >= end;\n    asc ? i++ : i--\n  ) {\n    ia[i] = byteString.charCodeAt(i);\n  }\n\n  // write the ArrayBuffer to a blob\n  return new Blob([ab], { type: mimeString });\n};\n\n// Returns an array without the rejected item\nconst without = (list, rejectedItem) =>\n  list.filter((item) => item !== rejectedItem).map((item) => item);\n\n// abc-def_ghi -> abcDefGhi\nconst camelize = (str) =>\n  str.replace(/[\\-_](\\w)/g, (match) => match.charAt(1).toUpperCase());\n\n// Creates an element from string\nDropzone.createElement = function (string) {\n  let div = document.createElement(\"div\");\n  div.innerHTML = string;\n  return div.childNodes[0];\n};\n\n// Tests if given element is inside (or simply is) the container\nDropzone.elementInside = function (element, container) {\n  if (element === container) {\n    return true;\n  } // Coffeescript doesn't support do/while loops\n  while ((element = element.parentNode)) {\n    if (element === container) {\n      return true;\n    }\n  }\n  return false;\n};\n\nDropzone.getElement = function (el, name) {\n  let element;\n  if (typeof el === \"string\") {\n    element = document.querySelector(el);\n  } else if (el.nodeType != null) {\n    element = el;\n  }\n  if (element == null) {\n    throw new Error(\n      `Invalid \\`${name}\\` option provided. Please provide a CSS selector or a plain HTML element.`\n    );\n  }\n  return element;\n};\n\nDropzone.getElements = function (els, name) {\n  let el, elements;\n  if (els instanceof Array) {\n    elements = [];\n    try {\n      for (el of els) {\n        elements.push(this.getElement(el, name));\n      }\n    } catch (e) {\n      elements = null;\n    }\n  } else if (typeof els === \"string\") {\n    elements = [];\n    for (el of document.querySelectorAll(els)) {\n      elements.push(el);\n    }\n  } else if (els.nodeType != null) {\n    elements = [els];\n  }\n\n  if (elements == null || !elements.length) {\n    throw new Error(\n      `Invalid \\`${name}\\` option provided. Please provide a CSS selector, a plain HTML element or a list of those.`\n    );\n  }\n\n  return elements;\n};\n\n// Asks the user the question and calls accepted or rejected accordingly\n//\n// The default implementation just uses `window.confirm` and then calls the\n// appropriate callback.\nDropzone.confirm = function (question, accepted, rejected) {\n  if (window.confirm(question)) {\n    return accepted();\n  } else if (rejected != null) {\n    return rejected();\n  }\n};\n\n// Validates the mime type like this:\n//\n// https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept\nDropzone.isValidFile = function (file, acceptedFiles) {\n  if (!acceptedFiles) {\n    return true;\n  } // If there are no accepted mime types, it's OK\n  acceptedFiles = acceptedFiles.split(\",\");\n\n  let mimeType = file.type;\n  let baseMimeType = mimeType.replace(/\\/.*$/, \"\");\n\n  for (let validType of acceptedFiles) {\n    validType = validType.trim();\n    if (validType.charAt(0) === \".\") {\n      if (\n        file.name\n          .toLowerCase()\n          .indexOf(\n            validType.toLowerCase(),\n            file.name.length - validType.length\n          ) !== -1\n      ) {\n        return true;\n      }\n    } else if (/\\/\\*$/.test(validType)) {\n      // This is something like a image/* mime type\n      if (baseMimeType === validType.replace(/\\/.*$/, \"\")) {\n        return true;\n      }\n    } else {\n      if (mimeType === validType) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// Augment jQuery\nif (typeof jQuery !== \"undefined\" && jQuery !== null) {\n  jQuery.fn.dropzone = function (options) {\n    return this.each(function () {\n      return new Dropzone(this, options);\n    });\n  };\n}\n\n// Dropzone file status codes\nDropzone.ADDED = \"added\";\n\nDropzone.QUEUED = \"queued\";\n// For backwards compatibility. Now, if a file is accepted, it's either queued\n// or uploading.\nDropzone.ACCEPTED = Dropzone.QUEUED;\n\nDropzone.UPLOADING = \"uploading\";\nDropzone.PROCESSING = Dropzone.UPLOADING; // alias\n\nDropzone.CANCELED = \"canceled\";\nDropzone.ERROR = \"error\";\nDropzone.SUCCESS = \"success\";\n\n/*\n\n Bugfix for iOS 6 and 7\n Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios\n based on the work of https://github.com/stomita/ios-imagefile-megapixel\n\n */\n\n// Detecting vertical squash in loaded image.\n// Fixes a bug which squash image vertically while drawing into canvas for some images.\n// This is a bug in iOS6 devices. This function from https://github.com/stomita/ios-imagefile-megapixel\nlet detectVerticalSquash = function (img) {\n  let iw = img.naturalWidth;\n  let ih = img.naturalHeight;\n  let canvas = document.createElement(\"canvas\");\n  canvas.width = 1;\n  canvas.height = ih;\n  let ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(img, 0, 0);\n  let { data } = ctx.getImageData(1, 0, 1, ih);\n\n  // search image edge pixel position in case it is squashed vertically.\n  let sy = 0;\n  let ey = ih;\n  let py = ih;\n  while (py > sy) {\n    let alpha = data[(py - 1) * 4 + 3];\n\n    if (alpha === 0) {\n      ey = py;\n    } else {\n      sy = py;\n    }\n\n    py = (ey + sy) >> 1;\n  }\n  let ratio = py / ih;\n\n  if (ratio === 0) {\n    return 1;\n  } else {\n    return ratio;\n  }\n};\n\n// A replacement for context.drawImage\n// (args are for source and destination).\nvar drawImageIOSFix = function (ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {\n  let vertSquashRatio = detectVerticalSquash(img);\n  return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);\n};\n\n// Based on MinifyJpeg\n// Source: http://www.perry.cz/files/ExifRestorer.js\n// http://elicon.blog57.fc2.com/blog-entry-206.html\nclass ExifRestore {\n  static initClass() {\n    this.KEY_STR =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n  }\n\n  static encode64(input) {\n    let output = \"\";\n    let chr1 = undefined;\n    let chr2 = undefined;\n    let chr3 = \"\";\n    let enc1 = undefined;\n    let enc2 = undefined;\n    let enc3 = undefined;\n    let enc4 = \"\";\n    let i = 0;\n    while (true) {\n      chr1 = input[i++];\n      chr2 = input[i++];\n      chr3 = input[i++];\n      enc1 = chr1 >> 2;\n      enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n      enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n      enc4 = chr3 & 63;\n      if (isNaN(chr2)) {\n        enc3 = enc4 = 64;\n      } else if (isNaN(chr3)) {\n        enc4 = 64;\n      }\n      output =\n        output +\n        this.KEY_STR.charAt(enc1) +\n        this.KEY_STR.charAt(enc2) +\n        this.KEY_STR.charAt(enc3) +\n        this.KEY_STR.charAt(enc4);\n      chr1 = chr2 = chr3 = \"\";\n      enc1 = enc2 = enc3 = enc4 = \"\";\n      if (!(i < input.length)) {\n        break;\n      }\n    }\n    return output;\n  }\n\n  static restore(origFileBase64, resizedFileBase64) {\n    if (!origFileBase64.match(\"data:image/jpeg;base64,\")) {\n      return resizedFileBase64;\n    }\n    let rawImage = this.decode64(\n      origFileBase64.replace(\"data:image/jpeg;base64,\", \"\")\n    );\n    let segments = this.slice2Segments(rawImage);\n    let image = this.exifManipulation(resizedFileBase64, segments);\n    return `data:image/jpeg;base64,${this.encode64(image)}`;\n  }\n\n  static exifManipulation(resizedFileBase64, segments) {\n    let exifArray = this.getExifArray(segments);\n    let newImageArray = this.insertExif(resizedFileBase64, exifArray);\n    let aBuffer = new Uint8Array(newImageArray);\n    return aBuffer;\n  }\n\n  static getExifArray(segments) {\n    let seg = undefined;\n    let x = 0;\n    while (x < segments.length) {\n      seg = segments[x];\n      if ((seg[0] === 255) & (seg[1] === 225)) {\n        return seg;\n      }\n      x++;\n    }\n    return [];\n  }\n\n  static insertExif(resizedFileBase64, exifArray) {\n    let imageData = resizedFileBase64.replace(\"data:image/jpeg;base64,\", \"\");\n    let buf = this.decode64(imageData);\n    let separatePoint = buf.indexOf(255, 3);\n    let mae = buf.slice(0, separatePoint);\n    let ato = buf.slice(separatePoint);\n    let array = mae;\n    array = array.concat(exifArray);\n    array = array.concat(ato);\n    return array;\n  }\n\n  static slice2Segments(rawImageArray) {\n    let head = 0;\n    let segments = [];\n    while (true) {\n      var length;\n      if ((rawImageArray[head] === 255) & (rawImageArray[head + 1] === 218)) {\n        break;\n      }\n      if ((rawImageArray[head] === 255) & (rawImageArray[head + 1] === 216)) {\n        head += 2;\n      } else {\n        length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3];\n        let endPoint = head + length + 2;\n        let seg = rawImageArray.slice(head, endPoint);\n        segments.push(seg);\n        head = endPoint;\n      }\n      if (head > rawImageArray.length) {\n        break;\n      }\n    }\n    return segments;\n  }\n\n  static decode64(input) {\n    let output = \"\";\n    let chr1 = undefined;\n    let chr2 = undefined;\n    let chr3 = \"\";\n    let enc1 = undefined;\n    let enc2 = undefined;\n    let enc3 = undefined;\n    let enc4 = \"\";\n    let i = 0;\n    let buf = [];\n    // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n    let base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n    if (base64test.exec(input)) {\n      console.warn(\n        \"There were invalid base64 characters in the input text.\\nValid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\\nExpect errors in decoding.\"\n      );\n    }\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n    while (true) {\n      enc1 = this.KEY_STR.indexOf(input.charAt(i++));\n      enc2 = this.KEY_STR.indexOf(input.charAt(i++));\n      enc3 = this.KEY_STR.indexOf(input.charAt(i++));\n      enc4 = this.KEY_STR.indexOf(input.charAt(i++));\n      chr1 = (enc1 << 2) | (enc2 >> 4);\n      chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n      chr3 = ((enc3 & 3) << 6) | enc4;\n      buf.push(chr1);\n      if (enc3 !== 64) {\n        buf.push(chr2);\n      }\n      if (enc4 !== 64) {\n        buf.push(chr3);\n      }\n      chr1 = chr2 = chr3 = \"\";\n      enc1 = enc2 = enc3 = enc4 = \"\";\n      if (!(i < input.length)) {\n        break;\n      }\n    }\n    return buf;\n  }\n}\nExifRestore.initClass();\n\n/*\n * contentloaded.js\n *\n * Author: Diego Perini (diego.perini at gmail.com)\n * Summary: cross-browser wrapper for DOMContentLoaded\n * Updated: 20101020\n * License: MIT\n * Version: 1.2\n *\n * URL:\n * http://javascript.nwbox.com/ContentLoaded/\n * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE\n */\n\n// @win window reference\n// @fn function reference\nlet contentLoaded = function (win, fn) {\n  let done = false;\n  let top = true;\n  let doc = win.document;\n  let root = doc.documentElement;\n  let add = doc.addEventListener ? \"addEventListener\" : \"attachEvent\";\n  let rem = doc.addEventListener ? \"removeEventListener\" : \"detachEvent\";\n  let pre = doc.addEventListener ? \"\" : \"on\";\n  var init = function (e) {\n    if (e.type === \"readystatechange\" && doc.readyState !== \"complete\") {\n      return;\n    }\n    (e.type === \"load\" ? win : doc)[rem](pre + e.type, init, false);\n    if (!done && (done = true)) {\n      return fn.call(win, e.type || e);\n    }\n  };\n\n  var poll = function () {\n    try {\n      root.doScroll(\"left\");\n    } catch (e) {\n      setTimeout(poll, 50);\n      return;\n    }\n    return init(\"poll\");\n  };\n\n  if (doc.readyState !== \"complete\") {\n    if (doc.createEventObject && root.doScroll) {\n      try {\n        top = !win.frameElement;\n      } catch (error) {}\n      if (top) {\n        poll();\n      }\n    }\n    doc[add](pre + \"DOMContentLoaded\", init, false);\n    doc[add](pre + \"readystatechange\", init, false);\n    return win[add](pre + \"load\", init, false);\n  }\n};\n\n// As a single function to be able to write tests.\nDropzone._autoDiscoverFunction = function () {\n  if (Dropzone.autoDiscover) {\n    return Dropzone.discover();\n  }\n};\ncontentLoaded(window, Dropzone._autoDiscoverFunction);\n\nfunction __guard__(value, transform) {\n  return typeof value !== \"undefined\" && value !== null\n    ? transform(value)\n    : undefined;\n}\nfunction __guardMethod__(obj, methodName, transform) {\n  if (\n    typeof obj !== \"undefined\" &&\n    obj !== null &&\n    typeof obj[methodName] === \"function\"\n  ) {\n    return transform(obj, methodName);\n  } else {\n    return undefined;\n  }\n}\n\nexport { Dropzone };\n"]},"metadata":{},"sourceType":"module"}